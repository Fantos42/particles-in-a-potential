---
title: 'MCMC Optimization with CPP'
output: html_document
---

Basically two functions of the MCMC routine are implemented as RCPP functions: The first one calculates the energy of a given system and the second calculates the difference in energy between two states. 


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(Rcpp)
```

```{r visualization, include=FALSE, echo=FALSE}
show_particles <- function(x, q, V){
  l <- V**(1/2)
  # dev.new(width = 550, height = 550, unit = "px")
  par(pty="s")
  plot(NA, xlim=c(-l/2, l/2), ylim=c(-l/2,l/2), xlab='x', ylab='y', asp=1)

  ipos <- which(q==+1)
  posParticles <- x[ipos,]
  # points(x=posParticles[,1],y=posParticles[,2], col='red' )
  arrows(x0=posParticles[,1]-0.5,
         y0=posParticles[,2],
         x1=posParticles[,1]+0.5,
         y1=posParticles[,2],
         length=0.01, angle=90, code=0, col='red')
  arrows(x0=posParticles[,1],
         y0=posParticles[,2]-0.5,
         x1=posParticles[,1],
         y1=posParticles[,2]+0.5,
         length=0.01, angle=90, code=0, col='red')

  ineg <- which(q==-1)
  negParticles <- x[ineg,]
  # points(x=negParticles[,1],y=negParticles[,2], col='blue')
  arrows(x0=negParticles[,1]-0.5,
         y0=negParticles[,2],
         x1=negParticles[,1]+0.5,
         y1=negParticles[,2],
         length=0.01, angle=90, code=0, col='blue')
  arrows(x0=negParticles[,1],
         y0=negParticles[,2]-0.5,
         x1=negParticles[,1],
         y1=negParticles[,2]+0.5,
         length=0.01, angle=90, code=0, col='blue')


  abline(h = -l/2)
  abline(h = +l/2)
  abline(v = -l/2)
  abline(v = +l/2)
}
```

```{r R_functions}
# Returns a candidate where the k-th particle was varied.
g_R <- function(x, k, V, sigma = 1) {
  if (length(x[1,])!=2) print("g is not defined for d!=2")
  
  l <- V**(1/2)
  pi_const <- 3.14159265359
  
  # Generate distance r and direction phi. Get new coord with spherical trafo.
  r <- rnorm(1, mean=0, sd=sigma)
  phi <- runif(1, min=0, max=1)
  x[k,] <- x[k,] + c(cos(phi*pi_const), sin(phi*pi_const)) * r

  # Periodic boundary wrap
  if      (x[k,1] < -l/2) { x[k,1] <- x[k,1] + l }
  else if (x[k,2] < -l/2) { x[k,2] <- x[k,2] + l }
  if      (x[k,1] > +l/2) { x[k,1] <- x[k,1] - l }
  else if (x[k,2] > +l/2) { x[k,2] <- x[k,2] - l }
  
  return(x)
}

# Returns the target distribution probability up to a normalization factor
E_R <- function(x, q) {
  n <- length(q)     # Number of particles
  d <- length(x[1,]) # Dimensions

  a <- 0 # Coulomb part
  b <- 0 # Hard shell part
  for (i in c(1:(n-1))) {
    for (j in c((i+1):n)) {
      a <- a + q[i] * q[j] / sqrt(sum((x[i,] - x[j,])**2))
      b <- b + 1 / (sqrt(sum((x[i,] - x[j,])**2)))**8
    }
  }
  return((a + b))
}

E_diff_R <- function(y, x, q, k) {
  n <- length(q)     # Number of particles
  d <- length(x[1,]) # Dimensions

  a <- 0 # Coulomb part
  b <- 0 # Hard shell part
  for (j in c(1:n)[-k]) {
    a <- a + q[k] * q[j] / sqrt(sum((y[k,] - y[j,])**2))
    a <- a - q[k] * q[j] / sqrt(sum((x[k,] - x[j,])**2))
    b <- b + 1 / sum((y[k,] - y[j,])**2)**4
    b <- b - 1 / sum((x[k,] - x[j,])**2)**4
  }
  return((a + b))
}
```

```{Rcpp Rcpp_functions}
// [[Rcpp::plugins("cpp11")]]
#include <Rcpp.h>
#include <vector>
#include <ctime>
using namespace Rcpp;

// [[Rcpp::export]]
NumericMatrix g_CPP(NumericMatrix X, int k, double v, double sigma = 1){
  if(X.ncol() != 2) Rcout << "g is not defined for d!=2" << std::endl;
  k = k - 1; // Shift index from R to CPP convention
  
  NumericMatrix x = X;
  double l = sqrt(v);
  NumericVector r   = rnorm(1, 0, sigma);
  NumericVector phi = runif(1, 0, 1);
  
  //Generate distance r and direction phi. Get new coord with spherical trafo
  NumericVector c = NumericVector::create(cos(phi[0]*M_PI)*r[0], sin(phi[0]*M_PI)*r[0]);
  
  for(int i=0; i < x.ncol(); i++){
    x(k, i) +=  c[i]; 
    // Periodic boundary wrap
    if      (x(k, i) < -l/2) x(k,i) += l;
    else if (x(k, i) > +l/2) x(k,i) -= l;  
  }
  return x;
}

std::vector<std::vector<double>> g_CPP(std::vector<std::vector<double>> x, int k, double v, double sigma = 1){
  int dim = x[0].size();
  if(dim != 2) Rcout << "g is not defined for d!=2" << std::endl;
  k = k - 1; // Shift index from R to CPP convention
  
  double l = sqrt(v);
  NumericVector r   = rnorm(1, 0, sigma);
  NumericVector phi = runif(1, 0, 1);
  
  //Generate distance r and direction phi. Get new coord with spherical trafo
  NumericVector c = NumericVector::create(cos(phi[0]*M_PI)*r[0], sin(phi[0]*M_PI)*r[0]);
  
  for(int d=0; d < dim; d++){
    x[k][d] +=  c(d); 
    // Periodic boundary wrap
    if      (x[k][d] < -l/2) x[k][d] += l;
    else if (x[k][d] > +l/2) x[k][d] -= l;  
  }
  return x;
}

// [[Rcpp::export]]
double E_CPP(NumericMatrix x, NumericVector q){
  int n = q.size(); //number of particles
  int d = x.ncol(); //dimensions
  
  double a, b, sum = 0;
  for(int i = 0; i < n-1; i++){
    for(int j = i+1; j < n; j++){
      sum = 0;
      for(int k = 0; k < d; k++){
        sum += (x(i,k) - x(j,k))*(x(i,k) - x(j,k));
      }
      a += q[i] * q[j] / sqrt(sum);
      b += 1 / pow(sum, 4); 
    }
  }
  return (a+b);
}

// [[Rcpp::export]]
double E_diff_CPP(NumericMatrix y, NumericMatrix x, NumericVector q, int k){
  int n = q.size(); //number of particles
  int d = x.ncol(); //dimensions
  k = k - 1;
  
  double a = 0;
  double b = 0; 
  double sumx = 0;
  double sumy = 0;
  for(int j = 0; j < n; j++){
    if(j == k) continue;
    sumx = 0;
    sumy = 0;
    
    for(int l = 0; l < d; l++){
      sumx += (x(k,l) - x(j,l))*(x(k,l) - x(j,l));
      sumy += (y(k,l) - y(j,l))*(y(k,l) - y(j,l));
    }
    
    a += q[k] * q[j] / sqrt(sumy);
    a -= q[k] * q[j] / sqrt(sumx);
    b += 1/ pow(sumy, 4);
    b -= 1/ pow(sumx, 4);
  }
  return (a+b);
}

double E_diff_CPP(std::vector<std::vector<double>> y, std::vector<std::vector<double>> x, NumericVector q, int k){
  int n = q.size(); //number of particles
  int d = x[0].size(); //dimensions
  k = k - 1;
  
  double a = 0;
  double b = 0; 
  double sumx = 0;
  double sumy = 0;
  for(int j = 0; j < n; j++){
    if(j == k) continue;
    sumx = 0;
    sumy = 0;
    
    for(int l = 0; l < d; l++){
      sumx += (x[k][l] - x[j][l])*(x[k][l] - x[j][l]);
      sumy += (y[k][l] - y[j][l])*(y[k][l] - y[j][l]);
    }
    
    a += q[k] * q[j] / sqrt(sumy);
    a -= q[k] * q[j] / sqrt(sumx);
    b += 1/ pow(sumy, 4);
    b -= 1/ pow(sumx, 4);
  }
  return (a+b);
}

// [[Rcpp::export]]
NumericMatrix MCMC_CPP(int nIt, int nPart, double vol, double t, NumericMatrix X0, NumericVector q){
  double sigma = 1;
  const double l = sqrt(vol);
  NumericVector dE(nIt, 0.0);
  dE[0] = E_CPP(X0, q);
  
  int d = X0(1,Rcpp::_).size();
  std::vector<std::vector<double>> X(nIt,std::vector<double>(d,0));
  //std::vector<std::vector<double>> Y(nIt,std::vector<double>(d,0));
  for (int i = 0; i < nPart; i++) {
    for (int j = 0; j < d; j++) {
      X[i][j] = X0(i,j);
  //    Y[i][j] = X0(i,j);
    }
  }
  
  double accept_rate = 0;
  for (int n = 1; n < nIt; n++) {
    const int k = std::floor(R::runif(0,nPart));
    // ---------------------------------------------------------------------------
    for(int j = 0; j < nPart; j++){
      if(j == k) continue;
      
      double sum = 0;
      for(int l = 0; l < d; l++){
        sum += (X[k][l] - X[j][l])*(X[k][l] - X[j][l]);
      }
      
      dE[n] -= q[k] * q[j] / sqrt(sum) + 1/ pow(sum, 4);
    }
    // ---------------------------------------------------------------------------
    //Y = g_CPP(X, k, vol, sigma);
    
    const double old_x1 = X[k][0];
    const double old_x2 = X[k][1];
    
    NumericVector r   = rnorm(1, 0, sigma);
    NumericVector phi = runif(1, 0, 1);
    //Generate distance r and direction phi. Get new coord with spherical trafo
    NumericVector c = NumericVector::create(cos(phi[0]*M_PI)*r[0], sin(phi[0]*M_PI)*r[0]);
    for(int i=0; i < d; i++){
      X[k][i] +=  c(i); 
      // Periodic boundary wrap
      if      (X[k][i] < -l/2) X[k][i] += l;
      else if (X[k][i] > +l/2) X[k][i] -= l;  
    }
    
    // ---------------------------------------------------------------------------
    //dE[n] = E_diff_CPP(Y, X, q, k);
    for(int j = 0; j < nPart; j++){
      if(j == k) continue;
      
      double sum = 0;
      for(int l = 0; l < d; l++){
        sum += (X[k][l] - X[j][l])*(X[k][l] - X[j][l]);
      }
      
      dE[n] += q[k] * q[j] / sqrt(sum) + 1/ pow(sum, 4);
    }
    // ---------------------------------------------------------------------------
    if (R::runif(0,1) < std::exp(-1/t * dE[n])) {
      //X = Y;
      accept_rate += 1;
    } else {
      dE[n] = 0;
      X[k][0] = old_x1;
      X[k][1] = old_x2;
    }
  }
  Rcout << "Acceptance: " << accept_rate/nIt*100. << std::endl;
  
  NumericMatrix rmat(nIt,1);
  rmat(Rcpp::_,0) = dE;
  return rmat;
}
```

```{r MCMC_R}
MCMC_R <- function(nIt, nPart, vol, t, X0, q) {
  sigma <- 1   # Stepwidth
  dE <- rep(0,nIt)
  dE[1] <- E_R(X0, q)

  # Create array for N phasespace points of nPart particles in d dimensions.
  d <- length(X0[1,])
  X <- array(data = NA, dim = c(nIt, nPart, d))
  X[1,,] <- X0

  # Execute Markov Chain to make new samples:
  accept_rate <- 0
  for (n in c(2:nIt)) {
    # Generate Y_n
    k <- sample(c(1:nPart), 1)
    y <- g_R(X[(n-1),,], k, vol, sigma)
    # Set X_n
    dE[n] <- E_diff_R(y, X[(n-1),,], q, k)
    if (runif(1) < exp(-1/t*dE[n])) {
      X[n,,] <- y
      accept_rate <- accept_rate + 1
    } else {
      dE[n] <- 0
      X[n,,] <- X[(n-1),,]
    }
  }
  # print(accept_rate/nIt*100.)
  return(list(X=X, dE=dE))
}
```

```{r MCMC_R_CPP_Hybrid}
MCMC_R_CPP_hybrid <- function(nIt, nPart, vol, t, X0, q) {
  sigma <- 1   # Stepwidth
  dE    <- rep(0,nIt)
  dE[1] <- E_CPP(X0, q)
  
  # Create array for N phasespace points of nPart particles in d dimensions.
  X <- array(data = NA, dim = c(nIt, nPart, d))
  X[1,,] <- X0

  # Execute Markov Chain to make new samples:
  accept_rate <- 0
  cat("nIt: ",nIt,'\n')
  for (n in c(2:nIt)) {
    # Generate Y_n
    k <- sample(c(1:nPart), 1)
    X[n,,] <- g_CPP(X[(n-1),,], k, vol, sigma)
    
    # Set X_n
    dE[n] <- E_diff_CPP(X[n,,], X[(n-1),,], q, k)
    if (runif(1) < exp(-1/t*dE[n])) {
      accept_rate <- accept_rate + 1
    } else {
      dE[n] <- 0
      X[n,,] <- X[(n-1),,]
    }
  }
  cat("Acceptance Rate:",accept_rate/(nIt-1)*100.,"% \n")
  return(list(X=X, dE=dE))
}
```

```{r setup}
# HYPERPARAMETERS:
d     <- 2    # Number of dimensions
particleDensity <- 0.2
vol   <- 5e4  # Volume of space
nIt   <- 1e4  # Number of iterations
beta  <- 0.1
# These below are implied
t     <- 1/beta # Temperature of heat bath
nPart <- ceiling(vol * particleDensity)  # Number of particles

# Start configuration is chosen uniform randomly in the centered cuboid with volume vol.
# X0 <- array(data = runif(nPart*d, min=-vol**(1/d)/2, max=vol**(1/d)/2), dim = c(nPart, d))
# X0 <- array(data = sample.int(c(1:floor(vol))))
X0 <- array(data = NA, dim = c(nPart, d))
particle_ids <- c(1:nPart)
nRow <- ceiling(sqrt(nPart))
nCol <- round  (sqrt(nPart))
for (i in c(1:nPart)) {
  X0[i,1] <- (floor((particle_ids[i]-1) / nCol)) * vol**(1/2) / nRow - vol**(1/2) * (1/2 - 1/2/nCol)
  X0[i,2] <- ((particle_ids[i]-1) %% nCol      ) * vol**(1/2) / nCol - vol**(1/2) * (1/2 - 1/2/nCol)
}
q  <- sample(c(-1,+1), size=nPart, replace=TRUE)
# q <- rep(1, nPart)
# for (j in c(2:nPart)) {
#   q[j] <- q[j-1]*-1
# }
# q <- c(rep(+1,ceiling(nPart/2)),rep(-1,floor(nPart/2)))
cat("Number of {positive, negative} particles: {", length(which(q==+1)), ",", length(which(q==-1)),"}\n")
```

```{r test_cpp_implementation}
# # Run R implementation of MCMC
# cat("Run R implementation. . .\n")
# start_time <- Sys.time()
# Rlist <- MCMC_R(nIt, nPart, vol, t, X0, q)
# cat("Runtime: ",as.double(t1<- Sys.time() - start_time, units='secs'),"\n")
# cat("Energy (indirect):",sum(Rlist$dE)                               ,"\n")
# cat("Energy (direct)  :",E_R(Rlist$X[nIt,,],q)                       ,"\n")

###########################################################################

cat("\nRun R+RCPP hybrid implementation. . .\n")
start_time <- Sys.time()
Rlist <- MCMC_R_CPP_hybrid(nIt, nPart, vol, t, X0, q)
cat("Runtime: ",as.double(t1<- Sys.time() - start_time, units='secs'),"\n")

cat("Energy (indirect):",b <- sum(Rlist$dE)          ,"\n")
# cat("Energy (direct)  :",E_R(Rlist$X[nIt,,],q)       ,"\n")
cat("Energy (direct)  :",a <- E_CPP(Rlist$X[nIt,,],q),"\n")
cat("indirect - direct:",b - a,"\n")

show_particles(Rlist$X[1,,]  ,q, vol)
show_particles(Rlist$X[nIt,,],q, vol)

# cat("Runtime improvement:",as.double(t2, units='secs')/as.double(t1, units='secs')*100,"%\n")

###########################################################################

cat("\nRun RCPP implementation. . .\n")
start_time <- Sys.time()
Rlist <- MCMC_CPP(nIt, nPart, vol, t, X0, q)
cat("Runtime: ",as.double(t2<- Sys.time() - start_time, units='secs'),"\n")

cat("Energy (indirect):",b <- sum(Rlist[,1])          ,"\n")
# cat("Energy (direct)  :",E_R(Rlist$X[nIt,,],q)       ,"\n")
# cat("Energy (direct)  :",a <- E_CPP(Rlist$X[nIt,,],q),"\n")
# cat("indirect - direct:",b - a,"\n")

# show_particles(Rlist$X[1,,]  ,q, vol)
# show_particles(Rlist$X[nIt,,],q, vol)

cat("Runtime improvement:",as.double(t2, units='secs')/as.double(t1, units='secs')*100,"%\n")


```

