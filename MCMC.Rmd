---
title: 'MCMC for particles in a potential'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(Rcpp)
library(LaplacesDemon) # IAT
library(scatterplot3d) # 3D Plotting
library(rgl)           # 3D Plotting
library(tidyverse)     # Remove duplicate elements
```

```{r visualization}
show_particles <- function(x, q, V){
  dim <- length(x[1,])
  l <- V**(1/dim)
  
  ipos <- which(q==+1)
  ineg <- which(q==-1)
  posParticles <- x[ipos,]
  negParticles <- x[ineg,]
  
  if (dim == 1) {
    plot(NA, xlim=c(-l/2, l/2), ylim=c(-1.5,1.5), xlab='x', ylab='')
  
    if (length(ipos)!=0) {
      arrows(x0=x[ipos,]-0.5,
             y0=0,
             x1=x[ipos,]+0.5,
             y1=0,
             length=0.02, angle=90, code=3, col='red')
      arrows(x0=x[ipos,],
             y0=1,
             x1=x[ipos,],
             y1=-1,
             length=0.02, angle=90, code=0, col='red')
    }
    if (length(ineg)!=0) {
      arrows(x0=x[ineg,]-0.5,
             y0=0,
             x1=x[ineg,]+0.5,
             y1=0,
             length=0.02, angle=90, code=3, col='blue')
      arrows(x0=x[ineg,],
             y0=1,
             x1=x[ineg,],
             y1=-1,
             length=0.02, angle=90, code=0, col='blue')
    }    
  } else if (dim == 2) {
    par(pty="s")
    plot(NA, xlim=c(-l/2, l/2), ylim=c(-l/2,l/2), xlab='x', ylab='y', asp=1)
    abline(h = -l/2)
    abline(h = +l/2)
    abline(v = -l/2)
    abline(v = +l/2)
    
    arrows(x0=posParticles[,1]-0.5,
           y0=posParticles[,2],
           x1=posParticles[,1]+0.5,
           y1=posParticles[,2],
           length=0.01, angle=90, code=0, col='red')
    arrows(x0=posParticles[,1],
           y0=posParticles[,2]-0.5,
           x1=posParticles[,1],
           y1=posParticles[,2]+0.5,
           length=0.01, angle=90, code=0, col='red')
    arrows(x0=negParticles[,1]-0.5,
           y0=negParticles[,2],
           x1=negParticles[,1]+0.5,
           y1=negParticles[,2],
           length=0.01, angle=90, code=0, col='blue')
    arrows(x0=negParticles[,1],
           y0=negParticles[,2]-0.5,
           x1=negParticles[,1],
           y1=negParticles[,2]+0.5,
           length=0.01, angle=90, code=0, col='blue')
  } else if (dim == 3) {
    ballradius <- 0.5
    open3d()
    plot3d(x=NA, y=NA, z=NA, xlim=c(-l/2,l/2),ylim=c(-l/2,l/2),zlim=c(-l/2,l/2), xlab="", ylab="", zlab="")
    spheres3d(x=posParticles[,1], y=posParticles[,2], z=posParticles[,3], col = "red",
              radius=ballradius)
    spheres3d(x=negParticles[,1], y=negParticles[,2], z=negParticles[,3], col = "blue",
              radius=ballradius)
  }
}
```

```{Rcpp Rcpp_functions}
// [[Rcpp::plugins("cpp11")]]
#include <Rcpp.h>
#include <vector>
using namespace Rcpp;

// [[Rcpp::export]]
double E_CPP(NumericMatrix x, NumericVector q){
  int n = q.size(); //number of particles
  int d = x.ncol(); //dimensions
  
  double a, b, sum = 0;
  for(int i = 0; i < n-1; i++){
    for(int j = i+1; j < n; j++){
      sum = 0;
      for(int k = 0; k < d; k++){
        sum += (x(i,k) - x(j,k))*(x(i,k) - x(j,k));
      }
      a += q[i] * q[j] / sqrt(sum);
      b += 1 / pow(sum, 4); 
    }
  }
  return (a+b);
}

int getFreeIndex(std::vector<int> idx, int k) {
  const int nPart = idx.size();
  
  for (int i = 0; i < nPart; i++) {
    if (idx[i]==1) k--;
    
    if (k == 0) {
      return i;
    }
  }
  
  return -1;
}

double getDist(std::vector<double> a, std::vector<double> b) {
  const int dim = a.size();
  
  double dist = 0;
  for (int i = 0; i < dim; i++) {
    dist += (a[i] - b[i])*(a[i] - b[i]);
  }
  return std::sqrt(dist);
}


double estimate_clstSize(std::vector<std::vector<double>> X) {
  const int nPart = X.size();
  
  const double min_dist = 2;
  
  std::vector<std::vector<int>> clusters;
  std::vector<int>              cluster_sizes;
  
  std::vector<int> idx(nPart, +1);
  int nFree = nPart;
  
  
  while (nFree > 0) 
  {
    Rcout << nFree << std::endl;
    // Choose first free particle for new cluster
    int k = -1;
    for (int i = 0; i < nPart; i++) 
    {
      if (idx[i] == 1) 
      {
        k = i;
        idx[i] = 0;
        nFree--;
      }
    }
    Rcout << k << std::endl;
    
    // Create new cluster vector
    std::vector<int> temp (nPart, -1);
    clusters.push_back(temp);
    clusters.back()[0] = k;
    cluster_sizes.push_back(1);
    
    
    // Iterate through all cluster particles and look for neighbours.
    for (int j = 0; j < cluster_sizes.back(); j++) 
    {
      const int clst_idx =clusters.back()[j];
      
      // Add all neighbours of particle j.
      for (int k = 0; k < nFree; k++) 
      {
        int free_idx = getFreeIndex(idx, k);
        
        if (getDist(X[clst_idx], X[free_idx]) < min_dist) {
          clusters.back()[cluster_sizes.back()]  = free_idx;
          cluster_sizes.back()  += 1; // Current cluster has grown by 1
          idx[free_idx]          = 0; // Particle has been assigned to a cluster
          nFree                 -= 1; // One further particle is assigned to a cluster
          k                     -= 1; // Neccessary for correct procedure
        }
        
      }
    }
  }
  
  return cluster_sizes.size();
}


// [[Rcpp::export]]
Rcpp::List MCMC_CPP(int nIt, int nPart, double vol, double t, double sigma, NumericMatrix X0, NumericVector q){
  int d = X0(1,Rcpp::_).size();
  const double l = std::pow(vol, 1./d);
  const double t0= t;
  
  // ----------------------- Observables
  NumericVector dE(nIt, 0.0);
  dE[0] = E_CPP(X0, q);
  
  const int N_clstSize_samples = 2;
  int k_clstSize               = 0;
  std::vector<double> clstSize(N_clstSize_samples, -1);
  const double stp_clstSize    = (nIt-1e5)/N_clstSize_samples;
  // -----------------------
  
  std::vector<std::vector<double>> X(nPart, std::vector<double>(d,0));
  for (int i = 0; i < nPart; i++) {
    for (int j = 0; j < d; j++) {
      X[i][j] = X0(i,j);
    }
  }
  double accept_rate = 0;
  int k  = -1;
  for (int n = 1; n < nIt; n++) {
    k = std::floor(R::runif(0,nPart));
    // ---------------------------------------------------------------------------
    for(int j = 0; j < nPart; j++){
      if(j == k) continue;
      
      double sum = 0;
      for(int dim = 0; dim < d; dim++){
        sum += (X[k][dim] - X[j][dim])*(X[k][dim] - X[j][dim]);
      }
      
      dE[n] -= q[k] * q[j] / sqrt(sum) + 1/ pow(sum, 4);
    }
    // ---------------------------------------------------------------------------
    // Make new candidates (Save old coordinates in case of rejection)
    std::vector<double> old_x(d,0);
    for (int i = 0; i < d; i++) old_x[i] = X[k][i];
    
    std::vector<double> shift_vec(d,0);
    if (d == 1) {
      const double r   = R::rnorm(0, sigma);
      shift_vec = {r};
    } else if (d == 2) {
      const double r   = R::rnorm(0, sigma);
      const double phi = R::runif(0, 1);
      shift_vec = {cos(phi*M_PI)*r, sin(phi*M_PI)*r};
    } else if (d == 3) {
      const double r   = R::rnorm(0, sigma);
      const double phi = R::runif(0, 1);
      const double theta=R::runif(0, 1);
      shift_vec = {cos(phi*M_PI)*sin(theta*M_PI)*r, sin(phi*M_PI)*sin(theta*M_PI)*r, cos(theta*M_PI)*r};
    }
    for(int i=0; i < d; i++){
      X[k][i] += shift_vec[i]; 
      // Periodic boundary wrap
      if      (X[k][i] < -l/2) X[k][i] += l;
      else if (X[k][i] > +l/2) X[k][i] -= l;
    }
    // ---------------------------------------------------------------------------
    for(int j = 0; j < nPart; j++){
      if(j == k) continue;
      
      double sum = 0;
      for(int l = 0; l < d; l++){
        sum += (X[k][l] - X[j][l])*(X[k][l] - X[j][l]);
      }
      
      dE[n] += q[k] * q[j] / sqrt(sum) + 1/ pow(sum, 4);
    }
    // ---------------------------------------------------------------------------
    if (n < 1e4) {
      t = std::exp(std::log(10) * (+2 + n / 1.e4 * (std::log10(t0)-2)));
    } else {
      t = t0;
    }
    if (R::runif(0,1) < std::exp(-1/t * dE[n])) {
      //X = Y;
      accept_rate += 1;
    } else {
      dE[n] = 0;
      for (int i = 0; i < d; i++) X[k][i] = old_x[i];
    }
    // ---------------------------------------------------------------------------
    // if ((n-1e5) >= k_clstSize * stp_clstSize) {
    //   clstSize[k_clstSize] = estimate_clstSize(X);
    //   k_clstSize++;
    //   Rcout << clstSize[k_clstSize] << std::endl; 
    // }
    // ---------------------------------------------------------------------------
  }
  //Rcout << "Acceptance: " << accept_rate/nIt*100. << "%" << std::endl;
  
  
  for (int i = 0; i < nPart; i++) {
    for (int j = 0; j < d; j++) {
      X0(i,j) = X[i][j];
    }
  }
  
  Rcpp::List rList = Rcpp::List::create(Named("dE")=dE, Named("X")=X0, Named("Accpetance")=accept_rate/nIt);
  return rList;
}

// [[Rcpp::export]]
double IAT_CPP(NumericVector x_){
  const int n = x_.size(); //number of particles
  std::vector<double> x (n, 0);
  for (int i = 0; i < n; i++) x [i] = x_(i);
  
  const int maxlag = std::max(3., n/2.);
  
  double mu = 0;
  for (int i = 0; i < n; i++) mu += x[i];
  mu /= n;
  
  double Ga0 = 0;
  double Ga1 = 0;
  double Ga2 = 0;
  double Ga3 = 0;
  
  double lg;
  
  lg = 0;
  for (int i = lg; i < n; i++) Ga0 += (x[i-lg] - mu) * (x[i] - mu) / (n-lg-1.);
  lg = 1;
  for (int i = lg; i < n; i++) Ga1 += (x[i-lg] - mu) * (x[i] - mu) / (n-lg-1.);
  lg = 2;
  for (int i = lg; i < n; i++) Ga2 += (x[i-lg] - mu) * (x[i] - mu) / (n-lg-1.);
  lg = 3;
  for (int i = lg; i < n; i++) Ga3 += (x[i-lg] - mu) * (x[i] - mu) / (n-lg-1.);
  
  double Ga [] = {Ga0+Ga1, Ga2+Ga3};
  
  double m = 1;
  double IAT = Ga[0];
  while ( (Ga[1]>0.0) && (Ga[1] < Ga[0] || Ga[1]>0.1) ) {
    m += 1;
    if (2*m+1 > maxlag) {
      Rcout << "Not enough data, maxlag= " << maxlag << std::endl;
      break;
    }
    Ga[0] = Ga[1];
    lg = 2*m;
    Ga[1] = 0;
    for (int i = lg; i < n; i++) Ga[1] += (x[i-lg] - mu) * (x[i] - mu) / (n-lg-1.);
    lg = 2*m + 1;
    for (int i = lg; i < n; i++) Ga[1] += (x[i-lg] - mu) * (x[i] - mu) / (n-lg-1.);
    IAT += Ga[0];
  }
  //Rcout << "Breakpoint: " << 2*m << std::endl;
  IAT = (-1. + 2. * IAT / Ga0) / 2.;
  return IAT;
}
```

```{r single_simulation}
# --------------------------------------------------------------------------------
# HYPERPARAMETERS:
d               <- 2    # Number of dimensions
particleDensity <- 0.1
vol             <- 1e3  # Volume of space
nIt             <- 4e5  # Number of iterations
beta            <- 1e2
# These below are implied
t     <- 1/beta # Temperature of heat bath
nPart <- ceiling(vol * particleDensity)  # Number of particles
l     <- vol**(1/d)
# --------------------------------------------------------------------------------
# Start configuration:
# --------------- ---------------------------------------
# --------------- Random positions
X0 <- array(data = runif(nPart*d, min=-vol**(1/d)/2, max=vol**(1/d)/2), dim = c(nPart, d))
# --------------- Positioned on a regular lattice
# X0 <- array(data = NA, dim = c(nPart, d))
# nRow  <- ceiling(nPart**(1./d))
# nCol  <- round  (nPart**(1./d))
# # 1 Dimension:
# for (i in c(1:nPart)) {
#   X0[i,1] <- (i-1) / nPart * vol - vol * (1/2 - 1/2/nRow)
# }
# # 2 Dimensions:
# for (i in c(1:nPart)) {
#   X0[i,1] <- (floor((i-1) / nCol)) * vol**(1/2) / nRow - vol**(1/2) * (1/2 - 1/2/nCol)
#   X0[i,2] <- ((i-1) %% nCol      ) * vol**(1/2) / nCol - vol**(1/2) * (1/2 - 1/2/nCol)
# }
# 3 Dimensions:
# for (i in c(1:nPart)) {
#   a <- floor( (i-1)                         / nRow/nCol)
#   b <- floor(((i-1)         - a*nCol*nRow)  / nCol     )
#   c <-       ((i-1)- b*nCol - a*nCol*nRow) %% nCol
#   X0[i,1] <- a/nRow * l - l/2 + l/nCol/2
#   X0[i,2] <- b/nCol * l - l/2 + l/nCol/2
#   X0[i,3] <- c/nCol * l - l/2 + l/nCol/2
# }

# --------------- ---------------------------------------
# --------------- Random charges
# q  <- sample(c(-1,+1), size=nPart, replace=TRUE)
# --------------- Alternating charges
# q <- rep(1, nPart)
# for (j in c(2:nPart)) {
#   q[j] <- q[j-1]*-1
# }
# --------------- First positive, then negative charges
q <- c(rep(+1,ceiling(nPart/2)),rep(-1,floor(nPart/2)))
# --------------- ---------------------------------------
show_particles(X0,q,vol)
cat("Number of {positive, negative} particles: {", length(which(q==+1)), ",", length(which(q==-1)),"}\n")
# --------------------------------------------------------------------------------
cat("\nRun MCMC particles in a potential . .\n")
start_time <- Sys.time()
MCMC_Single_Run <- MCMC_CPP(nIt, nPart, vol, t, sigma=1, X0, q)
cat("Runtime: ",as.double(t2<- Sys.time() - start_time, units='secs'),"\n")
show_particles(MCMC_Single_Run$X, q, vol)
cat("Acceptrate: ",MCMC_Single_Run$Accpetance,"\n")
# --------------------------------------------------------------------------------
rm(d, particleDensity, vol, beta, t, nPart, l, X0, q, start_time, t2)
# --------------------------------------------------------------------------------
```


```{r evaluation_acf}
E <- cumsum(MCMC_Single_Run$dE)
plot(x=c(1:nIt),y=E[c(1:nIt)]+abs(min(E[c(1:nIt)]))+1,type='l',log='y', xlim = c(1e2,nIt))

start_time <- Sys.time()
acf(E[c(1e5:nIt)], lag.max = 50000)
cat("ACF runtime: ", as.double(Sys.time() - start_time, units='secs')," seconds \n")
```

```{r evaluation_iat}
# start_time <- Sys.time()
# cat("IAT: ",IAT(E[c(1e5:nIt)]),"\n")
# cat("IAT runtime: ", as.double(Sys.time() - start_time, units='secs')," seconds \n")

start_time <- Sys.time()
cat("IAT_custom: ",IAT_CPP(E[c(1e5:2e5)]),"\n")
cat("IAT runtime: ", as.double(Sys.time() - start_time, units='secs')," seconds \n")

start_time <- Sys.time()
cat("IAT_custom: ",IAT_CPP(E[c(1e5:3e5)]),"\n")
cat("IAT runtime: ", as.double(Sys.time() - start_time, units='secs')," seconds \n")

start_time <- Sys.time()
cat("IAT_custom: ",IAT_CPP(E[c(1e5:4e5)]),"\n")
cat("IAT runtime: ", as.double(Sys.time() - start_time, units='secs')," seconds \n")

start_time <- Sys.time()
cat("IAT_custom: ",IAT_CPP(E[c(2e5:3e5)]),"\n")
cat("IAT runtime: ", as.double(Sys.time() - start_time, units='secs')," seconds \n")

start_time <- Sys.time()
cat("IAT_custom: ",IAT_CPP(E[c(3e5:4e5)]),"\n")
cat("IAT runtime: ", as.double(Sys.time() - start_time, units='secs')," seconds \n")

# rm(start_time)
```



```{r initial_creation_of_frame}
# !!!!!!!!!!!!! BE CAREFUL NOT TO OVERWRITE EXISTING DATA !!!!!!!!!!!!!!!!!
file_name <- "MCMC_Results_V3.RData"

# Columns:
# 1 "RUN_ID": Run No.
# 2 "IAT"  : Integrated Autocorrelation Time
# 3 "E_end": Energy of Last State
# 4 "dim"  : Number of Dimensions
# 5 "rho"  : Particle Density
# 6 "vol"  : Cuboid Volume
# 7 "beta" : Inverse Temperature
# 8 "nIt"  : Number of MCMC iteration steps
# 9 "nPart": Number of Simulated Particles
#10 "t"    : Temperature
#11 X_end  : 

resFrame <- data.frame(
  "RUN_ID"= 0,
  "IAT"   =NA,
  "E_end" =NA,
  "dim"   =NA,
  "rho"   =NA,
  "vol"   =NA,
  "beta"  =NA,
  "nIt"   =NA,
  "nPart" =NA,
  "t"     =NA
  )
# save(resFrame, file=file_name)

rm(resFrame)
rm(file_name)
```

```{r temperature variation}
# --------------------------------------------------------------------------------
# LOAD RESULTS DATA FRAME FROM DISK
file_name <- "MCMC_Results_V3.RData"
load(file_name)
# head(resFrame)
run_no <- max(resFrame$RUN_ID, na.rm=TRUE)+1
# --------------------------------------------------------------------------------
# HYPERPARAMETERS:
d               <- 2    # Number of dimensions
particleDensity <- 0.3
vol             <- 1e3  # Volume of space
nIt             <- 2e5  # Number of iterations
# beta            <- 1000
# These below are implied
# t     <- 1/beta # Temperature of heat bath
nPart <- ceiling(vol * particleDensity)  # Number of particles
l     <- vol**(1/d)
# --------------------------------------------------------------------------------
betas <- exp(log(10)*seq(from=-4, to=4, length.out=25))
# betas <- betas[which(betas>=1e-2)]
# betas <- betas[which(betas< 1e1)]
# --------------- ---------------------------------------
nResamples <- 2
# --------------------------------------------------------------------------------

swatch.mcmc <- rep(0, length(betas))
swatch.iats <- rep(0, length(betas))
swatch.iter <- rep(0, length(betas))

cat("Starting swipe (RUN_ID ",run_no,") over ",length(betas)," points:\n")
for (i in c(1:length(betas))) {
  cat("i:",i,", ",betas[i]," : ")
  
  temp.iats <- rep(NA, nResamples)
  for (j in c(1:nResamples)) {
    cat(j, ", ")
    swatch.iter_start <- Sys.time()
    
    X0 <- array(data = runif(nPart*d, min=-vol**(1/d)/2, max=vol**(1/d)/2), dim = c(nPart, d))
    q  <- sample(c(-1,+1), size=nPart, replace=TRUE)
    
    swatch.mcmc_start <- Sys.time()
    res <- MCMC_CPP(nIt, nPart, vol, 1/betas[i], sigma=1, X0, q) # Make Markov Chain
    swatch.mcmc[i] <- swatch.mcmc[i] + as.double(Sys.time() - swatch.mcmc_start, units='secs')
    
    E <- cumsum(res$dE)
    swatch.iats_start <- Sys.time()
    iat <- IAT_CPP(E[c(1e5:nIt)])
    swatch.iats[i] <- swatch.iats[i] + as.double(Sys.time() - swatch.iats_start, units='secs')

    # - - - - - - - - - SAVE RESULT TO FRAME
    resFrame <- rbind(resFrame, list(run_no, iat, E[nIt], d, particleDensity, vol, betas[i], nIt, nPart, 1/betas[i]))
    # - - - - - - - - - 
    swatch.iter[i] <- swatch.iter[i] + as.double(Sys.time() - swatch.iter_start, units='secs')
  }
  cat("dur.:",swatch.iter[i]/nResamples,"\n")
}

print(resFrame)
save(resFrame, file=file_name)
rm(resFrame)

plot(x=betas, y=swatch.mcmc/nResamples, xlab="BETA", ylab="DURATION per MCMC", type="b", ylim=c(0,1.05*max(c(swatch.mcmc/nResamples,swatch.iter/nResamples))), log="x")
points(x=betas, y=swatch.iats/nResamples, col="orange", type="b")
lines(x=betas, y=swatch.iter/nResamples, col="red")
rm(swatch.mcmc, swatch.iter, swatch.iats, swatch.mcmc_start, swatch.iter_start, swatch.iats_start)

rm(q, X0, temp.iats, E, i, j, nResamples, betas, d, particleDensity, vol, nIt, nPart, l, run_no, res, iat) #Cleanup
```

```{r plot_series}
# --------------------------------------------------------------------------------
# LOAD RESULTS DATA FRAME FROM DISK
file_name <- "MCMC_Results_V3.RData"
load(file_name)
# print(resFrame)
# --------------------------------------------------------------------------------
# HYPERPARAMETERS:
d               <- 2    # Number of dimensions
particleDensity <- 0.3
vol             <- 1e3  # Volume of space
# beta            <- 1000
# These below are implied
# t     <- 1/beta # Temperature of heat bath
nPart <- ceiling(vol * particleDensity)  # Number of particles
l     <- vol**(1/d)
# --------------------------------------------------------------------------------
x.beta <- resFrame$beta[!duplicated(resFrame$beta)]
x.beta <- sort(x.beta[!is.na(x.beta)])
# x.beta <- x.beta[which(x.beta<0.1)]
y.iat <- array(NA, dim= c(length(x.beta), 2)) # [,1]: IAT, [,2]: Standard Error

for (i in c(1:length(x.beta))) {
  idx <- which(resFrame$dim==d & resFrame$rho==particleDensity & resFrame$vol==vol & resFrame$beta==x.beta[i])
  if (length(idx)!=0) {
    y.iat[i,1] <- mean(resFrame$IAT[idx])
    y.iat[i,2] <- sqrt(var(resFrame$IAT[idx]) / length(resFrame$IAT[idx]))
  }
}

plot(x.beta, y.iat[ ,1], xlim=c(1e-3, max(x.beta,na.rm=TRUE)+1), ylim = c(1e1, max(y.iat[ ,1]+y.iat[ ,2],na.rm=TRUE)), type = "l", log="xy")
arrows(x0=x.beta, y0=y.iat[ ,1]-y.iat[ ,2], x1=x.beta, y1=y.iat[ ,1]+y.iat[ ,2], angle=90, code=3, length=0.05)

plot(x.beta, y.iat[ ,1], xlim=c(5e-5, 1e5), ylim = c(5e1, 1e5), type = "l", log="xy") 
arrows(x0=x.beta, y0=y.iat[ ,1]-y.iat[ ,2], x1=x.beta, y1=y.iat[ ,1]+y.iat[ ,2], angle=90, code=3, length=0.05)

# plot(1/x.beta, y.iat[ ,1], xlim=c(0.1, max(1/x.beta)+1), ylim = c(0, max(y.iat[ ,1]+y.iat[ ,2])), type = "b") 
# arrows(x0=1/x.beta, y0=y.iat[ ,1]-y.iat[ ,2], x1=1/x.beta, y1=y.iat[ ,1]+y.iat[ ,2], angle=90, code=3, length=0.2)

# plot(1/x.beta, y.iat[ ,1], xlim=c(0, 1000), ylim = c(0, 500), type = "b")
# arrows(x0=1/x.beta, y0=y.iat[ ,1]-y.iat[ ,2], x1=1/x.beta, y1=y.iat[ ,1]+y.iat[ ,2], angle=90, code=3, length=0.2)

rm(resFrame)
rm(x.beta, y.iat, i, d, particleDensity, vol, nPart, l, idx, file_name)
```

```{r}
plot(NA, NA, xlim=c(5e-5, 1e5), ylim = c(5e1, 1e5), type = "l", log="xy") 
x.ticks <- exp(log(10)*seq(from=-4, to=4, length.out=25))
abline(v=x.ticks, col="gray")
```

```{r plot_parallel_rho}
# --------------------------------------------------------------------------------
# LOAD RESULTS DATA FRAME FROM DISK
file_name <- "MCMC_Results_V3.RData"
load(file_name)
# print(resFrame)
# --------------------------------------------------------------------------------
# HYPERPARAMETERS:
d               <- 2    # Number of dimensions
vol             <- 1e3  # Volume of space
# --------------------------------------------------------------------------------
colors <- c("red", "green", "blue", "orange")

a.rho <- resFrame$rho[!duplicated(resFrame$rho)]
a.rho <- sort(a.rho[!is.na(a.rho)])

plot(NA, NA, xlim=c(1e-7, 1e5), ylim = c(5e1, 1e5), log="xy", xlab="Beta", ylab="IAT") 

for (ridx in c(1:length(a.rho))) {
  x.beta <- resFrame$beta[which(resFrame$rho==a.rho[ridx])]
  x.beta <- x.beta[!duplicated(x.beta)]
  x.beta <- sort(x.beta[!is.na(x.beta)])
  
  y.iat <- array(NA, dim= c(length(x.beta), 2)) # [,1]: IAT, [,2]: Standard Error
  for (i in c(1:length(x.beta))) {
    idx <- which(resFrame$dim==d & resFrame$rho==a.rho[ridx] & resFrame$vol==vol & resFrame$beta==x.beta[i])
    if (length(idx)!=0) {
      y.iat[i,1] <- mean(resFrame$IAT[idx])
      y.iat[i,2] <- sqrt(var(resFrame$IAT[idx]) / length(resFrame$IAT[idx]))
    }
  }
  
  lines(x.beta, y.iat[ ,1], col=colors[ridx]) 
  # arrows(x0=x.beta, y0=y.iat[ ,1]-y.iat[ ,2], x1=x.beta, y1=y.iat[ ,1]+y.iat[ ,2], angle=90, code=3, length=0.05)
}

legend("topleft",legend=c("Rho Values:",a.rho),col=colors[c(0:length(a.rho))], lty=c(0,rep(1,length(a.rho))), cex=1)

rm(resFrame)
rm(x.beta, y.iat, a.rho)
rm(file_name, d, vol)
rm(i, idx, ridx, colors)
```



