---
title: 'MCMC for particles in a potential'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

source("MCMC_functions.R")
source("DataFrameHelper.R")
```


```{r single_simulation}
# --------------------------------------------------------------------------------
# HYPERPARAMETERS:
d               <- 2    # Number of dimensions
particleDensity <- 0.05
vol             <- 2e3  # Volume of space
nIt             <- 1e7  # Number of iterations
beta            <- 1e2
# These below are implied
t     <- 1/beta # Temperature of heat bath
nPart <- ceiling(vol * particleDensity)  # Number of particles
l     <- vol**(1/d)
# --------------------------------------------------------------------------------
# Start configuration:
X0 <- array(data = runif(nPart*d, min=-vol**(1/d)/2, max=vol**(1/d)/2), dim = c(nPart, d))
q <- c(rep(+1,ceiling(nPart/2)),rep(-1,floor(nPart/2)))
# show_particles(X0               , q, vol)
# --------------------------------------------------------------------------------
cat("Run MCMC particles in a potential . .\n")

start_time <- Sys.time()
MCMC_Single_Run <- MCMC_CPP_Collective(nIt, nPart, vol, t, sigma=1, X0, q)
end_time <- Sys.time()
# --------------------------------------------------------------------------------
# pdf("particle_config_out.pdf")
show_particles(MCMC_Single_Run$X, q, vol)
# dev.off()
# --------------------------------------------------------------------------------
cat("Number of {positive, negative} particles: {", length(which(q==+1)), ",", length(which(q==-1)),"}\n")
cat("Runtime: ",as.double(t2<- end_time - start_time, units='secs'),"\n")
cat("Acceptrate: ", MCMC_Single_Run$Accpetance,"\n")
cat("Mean Cluster Size: ", MCMC_Single_Run$MeanClusterSize)
# --------------------------------------------------------------------------------
rm(d, particleDensity, vol, beta, t, nPart, l, X0, q, start_time, end_time, t2)
# --------------------------------------------------------------------------------
```

```{r evaluation_acf}
E <- cumsum(MCMC_Single_Run$dE)
x.ticks <- c(9e6: nIt)
plot(x=x.ticks,y=E[x.ticks],type='l',log='')
# plot(x=x.ticks,y=E[x.ticks]+abs(min(E[x.ticks]))+1,type='l',log='y')
rm(x.ticks)
```

```{r}
acf_range <- c((nIt-4e5):nIt)
start_time <- Sys.time()
acf(E[acf_range], lag.max = 25000)
cat("ACF runtime: ", as.double(Sys.time() - start_time, units='secs')," seconds \n")
```

```{r}
acf_range <- c((nIt-1e6):nIt)
start_time <- Sys.time()
cat("IAT_custom: ",IAT_CPP(E[acf_range]),"\n")
cat("IAT runtime: ", as.double(Sys.time() - start_time, units='secs')," seconds \n")
```

```{r evaluation_iat}
# start_time <- Sys.time()
# cat("IAT: ",IAT(E[c(1e5:nIt)]),"\n")
# cat("IAT runtime: ", as.double(Sys.time() - start_time, units='secs')," seconds \n")

start_time <- Sys.time()
cat("IAT_custom: ",IAT_CPP(E[c(3.9e6:nIt)]),"\n")
cat("IAT runtime: ", as.double(Sys.time() - start_time, units='secs')," seconds \n")

# start_time <- Sys.time()
# cat("IAT_custom: ",IAT_CPP(E[c(1e5:3e5)]),"\n")
# cat("IAT runtime: ", as.double(Sys.time() - start_time, units='secs')," seconds \n")

# start_time <- Sys.time()
# cat("IAT_custom: ",IAT_CPP(E[c(1e5:4e5)]),"\n")
# cat("IAT runtime: ", as.double(Sys.time() - start_time, units='secs')," seconds \n")

# start_time <- Sys.time()
# cat("IAT_custom: ",IAT_CPP(E[c(2e5:3e5)]),"\n")
# cat("IAT runtime: ", as.double(Sys.time() - start_time, units='secs')," seconds \n")

# start_time <- Sys.time()
# cat("IAT_custom: ",IAT_CPP(E[c(3e5:4e5)]),"\n")
# cat("IAT runtime: ", as.double(Sys.time() - start_time, units='secs')," seconds \n")

# rm(start_time)
```



```{r temperature_variation}
# --------------------------------------------------------------------------------
# LOAD RESULTS DATA FRAME FROM DISK
file_name <- "MCMC_Results_V4_w_q.RData"
load(file_name)
run_no <- max(resFrame$RUN_ID, na.rm=TRUE)+1
# --------------------------------------------------------------------------------
# HYPERPARAMETERS:
d               <- 3    # Number of dimensions
particleDensity <- 0.075
vol             <- 1e4  # Volume of space
nIt             <- 2e5  # Number of iterations
# These below are implied
nPart <- ceiling(vol * particleDensity)  # Number of particles
l     <- vol**(1/d)
# --------------------------------------------------------------------------------
betas <- exp(log(10)*seq(from=-4, to=5, length.out=45))
# betas <- betas[which(c(1:length(betas))%%2==0)]
# betas <- betas[which(c(1:length(betas))%%2==0)]
betas <- betas[which(betas>=1e1)]
# betas <- betas[which(betas< 1e1)]
# --------------- ---------------------------------------
nResamples <- 3
# --------------------------------------------------------------------------------

swatch.mcmc <- rep(0, length(betas))
swatch.iats <- rep(0, length(betas))
swatch.iter <- rep(0, length(betas))

cat("Starting swipe of ",nPart," particles (RUN_ID ",run_no,") over ",length(betas)," points:\n")
for (i in c(1:length(betas))) {
  cat("i:",i,", ",betas[i]," : ")
  
  temp.iats <- rep(NA, nResamples)
  for (j in c(1:nResamples)) {
    cat(j, ", ")
    swatch.iter_start <- Sys.time()
    
    X0 <- array(data = runif(nPart*d, min=-vol**(1/d)/2, max=vol**(1/d)/2), dim = c(nPart, d))
    q  <- sample(c(-1,+1), size=nPart, replace=TRUE)
    
    swatch.mcmc_start <- Sys.time()
    res <- MCMC_CPP(nIt, nPart, vol, 1/betas[i], sigma=1, X0, q) # Make Markov Chain
    swatch.mcmc[i] <- swatch.mcmc[i] + as.double(Sys.time() - swatch.mcmc_start, units='secs')
    
    E <- cumsum(res$dE)
    
    swatch.iats_start <- Sys.time()
    iat <- 1
    # iat <- IAT_CPP(E[c(1e5:nIt)])
    swatch.iats[i] <- swatch.iats[i] + as.double(Sys.time() - swatch.iats_start, units='secs')

    # - - - - - - - - - SAVE RESULT TO FRAME
    resFrame <- rbind(resFrame, list(run_no, iat, E[nIt], res$MeanClusterSize, d, particleDensity, vol, betas[i], nIt, nPart, 1/betas[i]))
    # - - - - - - - - - 
    swatch.iter[i] <- swatch.iter[i] + as.double(Sys.time() - swatch.iter_start, units='secs')
  }
  cat("dur.:",swatch.iter[i]/nResamples,"\n")
}

save(resFrame, file=file_name)
# print(resFrame)
rm(resFrame)

# plot(x=betas, y=swatch.mcmc/nResamples, xlab="BETA", ylab="DURATION per MCMC", type="b", ylim=c(0,1.05*max(c(swatch.mcmc/nResamples,swatch.iter/nResamples))), log="x")
# points(x=betas, y=swatch.iats/nResamples, col="orange", type="b")
# lines(x=betas, y=swatch.iter/nResamples, col="red")
rm(swatch.mcmc, swatch.iter, swatch.iats, swatch.mcmc_start, swatch.iter_start, swatch.iats_start)

rm(q, X0, temp.iats, E, i, j, nResamples, betas, d, particleDensity, vol, nIt, nPart, l, run_no, res, iat) #Cleanup
```

```{r plot_temperature_series_beta}
# --------------------------------------------------------------------------------
# LOAD RESULTS DATA FRAME FROM DISK
file_name <- "MCMC_Results_V4_w_q.RData"
load(file_name)
# print(resFrame)
# --------------------------------------------------------------------------------
# HYPERPARAMETERS:
d               <- 1    # Number of dimensions
particleDensity <- 0.5
vol             <- 2e2  # Volume of space
# beta            <- 1000
# These below are implied
# t     <- 1/beta # Temperature of heat bath
nPart <- ceiling(vol * particleDensity)  # Number of particles
l     <- vol**(1/d)
# --------------------------------------------------------------------------------
x.beta <- resFrame$beta[!duplicated(resFrame$beta)]
x.beta <- sort(x.beta[!is.na(x.beta)])
# x.beta <- x.beta[which(x.beta<0.1)]
y.iat <- array(NA, dim= c(length(x.beta), 2)) # [,1]: IAT, [,2]: Standard Error

for (i in c(1:length(x.beta))) {
  idx <- which(resFrame$dim==d & resFrame$rho==particleDensity & resFrame$vol==vol & resFrame$beta==x.beta[i])
  if (length(idx)!=0) {
    y.iat[i,1] <- mean(resFrame$IAT[idx])
    y.iat[i,2] <- sqrt(var(resFrame$IAT[idx]) / length(resFrame$IAT[idx]))
  }
}

plot(x.beta, y.iat[ ,1], xlim=c(5e-5, 1e5), ylim = c(5e1, 1e5), type = "l", log="xy") 
arrows(x0=x.beta, y0=y.iat[ ,1]-y.iat[ ,2], x1=x.beta, y1=y.iat[ ,1]+y.iat[ ,2], angle=90, code=3, length=0.05)
lines(x=x.beta[which(x.beta>1e1)],y=1.6e4+1e-5*x.beta[which(x.beta>1e1)], col="red")
lines(x=x.beta[which(x.beta<1e1)],y=1e2+1e3*x.beta[which(x.beta<1e1)], col="red")

rm(resFrame)
rm(x.beta, y.iat, i, d, particleDensity, vol, nPart, l, idx, file_name)
```

```{r plot_ticks}
plot(NA, NA, xlim=c(5e-5, 1e5), ylim = c(5e1, 1e5), type = "l", log="xy") 
x.ticks <- exp(log(10)*seq(from=-4, to=5, length.out=46))

x.ticks <- x.ticks[which(c(1:length(x.ticks))%%2==0)]
x.ticks <- x.ticks[which(c(1:length(x.ticks))%%2==1)]

print(x.ticks)
abline(v=x.ticks, col="gray")
```

```{r plot_parallel_rho}
# --------------------------------------------------------------------------------
# LOAD RESULTS DATA FRAME FROM DISK
file_name <- "MCMC_Results_V4_w_q.RData"
load(file_name)
# print(resFrame)
# --------------------------------------------------------------------------------
# HYPERPARAMETERS:
d               <- 1    # Number of dimensions
vol             <- 2e2  # Volume of space
# --------------------------------------------------------------------------------
colors <- c("red", "green", "blue", "orange")

a.rho <- resFrame$rho[which(resFrame$dim==d & resFrame$vol==vol)][!duplicated(resFrame$rho)]
a.rho <- sort(a.rho[!is.na(a.rho)])

plot(NA, NA, xlim=c(1e-7, 1e5), ylim = c(5e1, 1e5), log="xy", xlab="Beta", ylab="IAT") 

for (ridx in c(1:length(a.rho))) {
  x.beta <- resFrame$beta[which(resFrame$rho==a.rho[ridx])]
  x.beta <- x.beta[!duplicated(x.beta)]
  x.beta <- sort(x.beta[!is.na(x.beta)])
  
  y.iat <- array(NA, dim= c(length(x.beta), 2)) # [,1]: IAT, [,2]: Standard Error
  for (i in c(1:length(x.beta))) {
    idx <- which(resFrame$dim==d & resFrame$rho==a.rho[ridx] & resFrame$vol==vol & resFrame$beta==x.beta[i])
    if (length(idx)!=0) {
      y.iat[i,1] <- mean(resFrame$IAT[idx])
      y.iat[i,2] <- sqrt(var(resFrame$IAT[idx]) / length(resFrame$IAT[idx]))
    }
  }
  
  lines(x.beta, y.iat[ ,1], col=colors[ridx]) 
  # arrows(x0=x.beta, y0=y.iat[ ,1]-y.iat[ ,2], x1=x.beta, y1=y.iat[ ,1]+y.iat[ ,2], angle=90, code=3, length=0.05)
}

legend("topleft",legend=c("Rho Values:",a.rho),col=colors[c(0:length(a.rho))], lty=c(0,rep(1,length(a.rho))), cex=1)

rm(resFrame)
rm(x.beta, y.iat, a.rho)
rm(file_name, d, vol)
rm(i, idx, ridx, colors)
```



```{r plot_temperature_series_q}
# --------------------------------------------------------------------------------
file_name <- "MCMC_Results_V4_w_q.RData"
load(file_name)
# --------------------------------------------------------------------------------
d               <- 3   
particleDensity <- 0.075
vol             <- 1e4 
# --------------------------------------------------------------------------------
betaVals <- myGetBetaValues(dim=d, vol=vol, rho=particleDensity)

# x.beta <- x.beta[which(x.beta>3e0)]

plt.data <- myGetMeanQValues(dim=d, vol=vol, rho=particleDensity, beta=betaVals)
rm(betaVals)


myPlotData(plt.data)

rm(resFrame)
rm(x.beta, plt.data, d, particleDensity, vol, file_name)
```
```{r plot_parallel_rho_for_q}
# --------------------------------------------------------------------------------
# LOAD RESULTS DATA FRAME FROM DISK
file_name <- "MCMC_Results_V4_w_q.RData"
load(file_name)
# --------------------------------------------------------------------------------
# HYPERPARAMETERS:
d               <- 3    # Number of dimensions
vol             <- 1e4  # Volume of space
# --------------------------------------------------------------------------------
colors <- c("red", "green", "blue", "orange", "purple", "pink", "magenta", "yellow")

a.rho <- resFrame$rho[which(resFrame$dim==d & resFrame$vol==vol)]
a.rho <- a.rho[!duplicated(a.rho)]
a.rho <- sort(a.rho[!is.na(a.rho)])

ylim <- c(1e0, max(resFrame$q[which(resFrame$dim==d & resFrame$vol==vol)]))

plot(NA, NA, xlim=c(5e-5, 1e5), ylim = ylim, log="x", xlab="1/T", ylab="q") 

for (ridx in c(1:length(a.rho))) {
  x.beta <- resFrame$beta[which(resFrame$rho==a.rho[ridx] & resFrame$dim==d & resFrame$vol==vol)]
  x.beta <- x.beta[!duplicated(x.beta)]
  x.beta <- sort(x.beta[!is.na(x.beta)])

  y.q <- array(NA, dim= c(length(x.beta), 2)) # [,1]: IAT, [,2]: Standard Error
  for (i in c(1:length(x.beta))) {
    idx <- which(resFrame$dim==d & resFrame$rho==a.rho[ridx] & resFrame$vol==vol & resFrame$beta==x.beta[i])
    if (length(idx)!=0) {
      y.q[i,1] <- mean(resFrame$q[idx])
      y.q[i,2] <- sqrt(var(resFrame$q[idx]) / length(idx))
    }
  }

  y.q[,2][which(y.q[ ,2] < 1e0)] <- NA
  err_low <- y.q[ ,1]-y.q[ ,2]
  err_high<- y.q[ ,1]+y.q[ ,2]
  
  lines(x.beta, y.q[ ,1], col=colors[ridx]) 
  points(x.beta, y.q[ ,1], pch=4, col="black", cex=0.5)
  arrows(x0=x.beta, y0=y.q[ ,1]-y.q[ ,2], x1=x.beta, y1=y.q[ ,1]+y.q[ ,2], angle=90, code=3, length=0.05)
}

legend("topleft",legend=c("Rho Values:",a.rho),col=c(0,colors[c(1:length(a.rho))]), lty=c(0,rep(1,length(a.rho))), cex=1)

rm(resFrame)
rm(x.beta, y.q, a.rho)
rm(file_name, d, vol)
rm(i, idx, ridx, colors)
```






```{r bootstrap_errors}
getBootstrapMeanError <- function(data){
  N <- length(data)
  N_replicas <- 10*N
  id <- array(sample.int(n=N, size=N_replicas*N, replace = TRUE), dim = c(N_replicas, N))
  
  replicas <- array(data[id], dim = c(N_replicas, N))
  mean_rep <- apply(X = replicas, MARGIN = 1, FUN = mean)
  st_error <- sd(mean_rep)
  return(st_error)
}

chisqr <- function(par, x, y, dy){
  f <- par[1]*x + par[2]
  return(sum((y-f)**2/dy**2))
}

myFit <- function(par, x, y, dy){
  myfit <- optim(par=par, fn=chisqr, y=y, dy=dy, x=x)
  return(list(a=myfit$par[1], b=myfit$par[2], chi2=myfit$value))
}

myFitErrors <- function(x, y, dy){
  N <- length(y)
  N_replicas <- 1500
  replicas <- array(data = NA, dim = c(N_replicas, N))
  for (i in c(1:N)) {
    replicas[ ,i] <- rnorm(n = N_replicas, mean=y[i], sd=dy[i])
  }
  #calculate best fit values (minimise chi2)
  par <- c(1,0)
  best_par <- array(data = NA, dim = c(N_replicas, length(par)+1))
  for (j in c(1:N_replicas)) {
    myfit <- optim(par = par, fn =chisqr, x=x, y=replicas[j, ], dy=dy)
    best_par[j, c(1:length(par))] <- myfit$par
    best_par[j, length(par)+1] <- myfit$value
  }  
  
  #---control results--------------------------------------------------
  # hist(best_par[ ,3], breaks = 100)
  # qqplot(x=qchisq(p = seq(0, 1, 1/N_replicas), df=1, ncp=0.54), y=best_par[ ,3], xlab = "Theoretical Qunatiles", ylab = "Sample Quantiles")
  # hist(best_par[ ,1], breaks = 15, probability = TRUE)
  # qqnorm(best_par[ ,1])
  # hist(best_par[ ,2], breaks = 10, probability = TRUE)
  # qqnorm(best_par[ ,2])
  #--------------------------------------------------------------------
 
   # res_fit <- list(params=c(mean(best_par[ , 1]), mean(best_par[ ,2])), error_params=c(sd(best_par[ , 1]), sd(best_par[ , 2])), chi2 = mean(best_par[ , 3]), error_chi2 = sd(best_par[ ,3]))
  # 
  # return(res_fit)
  return(best_par)
}
```

```{r test_error_calc}
#test------------------------------------------------------------------------------------------------------------
#test error calculation
test <- data.frame(t = c(0,2,4), y= c(0.9417029, 1.9538151, 3.1536958), deltay = c(0.110, 0.095, 0.130))
par <- c(0,1)
res <- myFit(par, test$t, test$y, test$deltay)
res

#test error band plotting
mx <- seq(0,4,0.01)
my <- res$a*mx + res$b
bpars <- myFitErrors(test$t, test$y, test$deltay)

Y <- (apply(bpars[ , c(1:2)], MARGIN = 1, FUN = function(parameter, x){parameter[1]*x + parameter[2]}, x=mx))
dY <- apply(Y, MARGIN = 1, FUN = sd)
plot(x=NA, y=NA, xlim = c(min(test$t), max(test$t)) , ylim = c(0.8,3.5))
polygon(x = c(mx, rev(mx)), y = c(my+dY, rev(my-dY)), col = "green", border = "green")
points(x=test$t,y=test$y)
arrows(x0=test$t, y0=test$y - test$deltay, x1 = test$t, y1=test$y + test$deltay, angle=90, code=3, length=0.05)
lines(x=mx, y=my)
#-----------------------------------------------------------------------------------------------------------------
```

```{r plot_results_with_fit}
# --------------------------------------------------------------------------------
# LOAD RESULTS DATA FRAME FROM DISK
file_name <- "MCMC_Results_V4_w_q.RData"
load(file_name)
# --------------------------------------------------------------------------------
# HYPERPARAMETERS:
d               <- 1    # Number of dimensions
particleDensity <- 0.5
vol             <- 2e2  # Volume of space
nPart <- ceiling(vol * particleDensity)  # Number of particles
l     <- vol**(1/d)
# --------------------------------------------------------------------------------

param <- c(1,1) #slope, y-intercept initial values fit parameter, tbd

# --------------------------------------------------------------------------------
x.beta <- resFrame$beta[which(resFrame$dim==d & resFrame$vol==vol & resFrame$rho==particleDensity)]
x.beta <- x.beta[!duplicated(x.beta)]
x.beta <- sort(x.beta[!is.na(x.beta)])
y.iat <- array(NA, dim= c(length(x.beta), 2)) # [,1]: IAT, [,2]: Standard Error

for (i in c(1:length(x.beta))) {
  idx <- which(resFrame$dim==d & resFrame$rho==particleDensity & resFrame$vol==vol & resFrame$beta==x.beta[i])
  if (length(idx)!=0) {
    y.iat[i,1] <- mean(resFrame$IAT[idx])
    y.iat[i,2] <- getBootstrapMeanError(resFrame$IAT[idx])
  }
}

#----------------------------------------------------------------------------------------------------------------
#plot fit with error band:
fit_range <- c(1e-4, 1e1)
interval_fit <- which(x.beta>=fit_range[1] & x.beta<fit_range[2]) # interval in which a straight line is fitted, tbd
res_fit <- myFit(param, x.beta[interval_fit], y.iat[interval_fit,1], y.iat[interval_fit,2]) #result parameters fit

xvals <- exp(log(10)*seq(from=-4, to=5, length.out=46)) # x values
xvals <- xvals[which(xvals>=fit_range[1] & xvals<fit_range[2])]
fit_line <- res_fit$a*xvals + res_fit$b # fit line

bpars <- myFitErrors(x.beta[interval_fit], y.iat[interval_fit,1], y.iat[interval_fit,2]) # bootstrap replicas for fit parameters

Y <- apply(bpars[ , c(1:2)], MARGIN = 1, FUN = function(parameter, x){parameter[1]*x + parameter[2]}, x=xvals)
dY <- apply(Y, MARGIN = 1, FUN = sd)

plot(x=NA, y=NA, xlim=c(5e-5, 1e5), ylim = c(5e1, 1e5), log="xy", xlab="1/T", ylab="IAT")
polygon(x = c(xvals, rev(xvals)), y = c(fit_line+dY, rev(fit_line-dY)), col = "green", border = "green")
points(x = x.beta, y = y.iat[ ,1])
arrows(x0=x.beta, y0=y.iat[ ,1]-y.iat[ ,2], x1=x.beta, y1=y.iat[ ,1]+y.iat[ ,2], angle=90, code=3, length=0.05)
lines(x=xvals, y=fit_line)
cat("Parameter a: ", res_fit$a, " +- ", sd(bpars[,1]), "\n")
cat("Parameter b: ", res_fit$b, " +- ", sd(bpars[,2]), "\n")
cat("Chisqr of fit: ", res_fit$chi2, "\n")
#----------------------------------------------------------------------------------------------------------------

rm(resFrame)
rm(x.beta, y.iat, i, d, particleDensity, vol, nPart, l, idx, file_name)
```
