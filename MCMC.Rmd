---
title: 'MCMC for particles in a potential'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(Rcpp)
# library(LaplacesDemon) # IAT
# library(scatterplot3d) # 3D Plotting
library(rgl)           # 3D Plotting
library(tidyverse)     # Remove duplicate elements
```

```{r visualization}
show_particles <- function(x, q, V){
  dim <- length(x[1,])
  l <- V**(1/dim)
  
  ipos <- which(q==+1)
  ineg <- which(q==-1)
  posParticles <- x[ipos,]
  negParticles <- x[ineg,]
  
  # pdf("test.pdf")
  if (dim == 1) {
    yLength <- 0.5
    plot(NA, xlim=c(-l/2, l/2), ylim=c(-1.5,1.5), xlab='x', ylab='', yaxt='n')
    
    if (length(ipos)!=0) {
      arrows(x0=x[ipos,]-0.5,
             y0=0,
             x1=x[ipos,]+0.5,
             y1=0,
             length=0.02, angle=90, code=3, col='red')
      arrows(x0=x[ipos,],
             y0=yLength,
             x1=x[ipos,],
             y1=-yLength,
             length=0.02, angle=90, code=0, col='red')
    }
    if (length(ineg)!=0) {
      arrows(x0=x[ineg,]-0.5,
             y0=0,
             x1=x[ineg,]+0.5,
             y1=0,
             length=0.02, angle=90, code=3, col='blue')
      arrows(x0=x[ineg,],
             y0=yLength,
             x1=x[ineg,],
             y1=-yLength,
             length=0.02, angle=90, code=0, col='blue')
    }    
  } else if (dim == 2) {
    par(pty="s")
    plot(NA, xlim=c(-l/2, l/2), ylim=c(-l/2,l/2), xlab='x-axis', ylab='y-axis', asp=1)
    
    arrows(x0=posParticles[,1]-0.5,
           y0=posParticles[,2],
           x1=posParticles[,1]+0.5,
           y1=posParticles[,2],
           length=0.01, angle=90, code=0, col='red')
    arrows(x0=posParticles[,1],
           y0=posParticles[,2]-0.5,
           x1=posParticles[,1],
           y1=posParticles[,2]+0.5,
           length=0.01, angle=90, code=0, col='red')
    arrows(x0=negParticles[,1]-0.5,
           y0=negParticles[,2],
           x1=negParticles[,1]+0.5,
           y1=negParticles[,2],
           length=0.01, angle=90, code=0, col='blue')
    arrows(x0=negParticles[,1],
           y0=negParticles[,2]-0.5,
           x1=negParticles[,1],
           y1=negParticles[,2]+0.5,
           length=0.01, angle=90, code=0, col='blue')
    
    lines(c(-l/2,-l/2,l/2,l/2,-l/2),c(-l/2,l/2,l/2,-l/2,-l/2))
  } else if (dim == 3) {
    ballradius <- 0.5
    open3d()
    plot3d(x=NA, y=NA, z=NA, xlim=c(-l/2,l/2),ylim=c(-l/2,l/2),zlim=c(-l/2,l/2), xlab="", ylab="", zlab="")
    spheres3d(x=posParticles[,1], y=posParticles[,2], z=posParticles[,3], col = "red",
              radius=ballradius)
    spheres3d(x=negParticles[,1], y=negParticles[,2], z=negParticles[,3], col = "blue",
              radius=ballradius)
  }
  # dev.off()
}


```

```{Rcpp Rcpp_IAP}
// [[Rcpp::plugins("cpp11")]]
#include <Rcpp.h>
#include <vector>
using namespace Rcpp;

// =======================================================
// ========================================= IAP_CPP
// =======================================================
// [[Rcpp::export]]
double IAT_CPP(NumericVector x_){
  const int n = x_.size(); //number of particles
  std::vector<double> x (n, 0);
  for (int i = 0; i < n; i++) x [i] = x_(i);
  
  const int maxlag = std::max(3., n/2.);
  
  double mu = 0;
  for (int i = 0; i < n; i++) mu += x[i];
  mu /= n;
  
  double Ga0 = 0;
  double Ga1 = 0;
  double Ga2 = 0;
  double Ga3 = 0;
  
  double lg;
  
  lg = 0;
  for (int i = lg; i < n; i++) Ga0 += (x[i-lg] - mu) * (x[i] - mu) / (n-lg-1.);
  lg = 1;
  for (int i = lg; i < n; i++) Ga1 += (x[i-lg] - mu) * (x[i] - mu) / (n-lg-1.);
  lg = 2;
  for (int i = lg; i < n; i++) Ga2 += (x[i-lg] - mu) * (x[i] - mu) / (n-lg-1.);
  lg = 3;
  for (int i = lg; i < n; i++) Ga3 += (x[i-lg] - mu) * (x[i] - mu) / (n-lg-1.);
  
  double Ga [] = {Ga0+Ga1, Ga2+Ga3};
  
  double m = 1;
  double IAT = Ga[0];
  while ( (Ga[1]>0.0) && (Ga[1] < Ga[0] || Ga[1]>0.1) ) {
    m += 1;
    if (2*m+1 > maxlag) {
      Rcout << "Not enough data, maxlag= " << maxlag << std::endl;
      return maxlag;
    }
    Ga[0] = Ga[1];
    lg = 2*m;
    Ga[1] = 0;
    for (int i = lg; i < n; i++) Ga[1] += (x[i-lg] - mu) * (x[i] - mu) / (n-lg-1.);
    lg = 2*m + 1;
    for (int i = lg; i < n; i++) Ga[1] += (x[i-lg] - mu) * (x[i] - mu) / (n-lg-1.);
    IAT += Ga[0];
  }
  //Rcout << "Breakpoint: " << 2*m << std::endl;
  IAT = (-1. + 2. * IAT / Ga0) / 2.;
  return IAT;
}
```

```{Rcpp Rcpp_MCMC}
// [[Rcpp::plugins("cpp11")]]
#include <Rcpp.h>
#include <vector>
using namespace Rcpp;

// [[Rcpp::export]]
double E_CPP(NumericMatrix x, NumericVector q){
  int n = q.size(); //number of particles
  int d = x.ncol(); //dimensions
  
  double a, b, sum = 0;
  for(int i = 0; i < n-1; i++){
    for(int j = i+1; j < n; j++){
      sum = 0;
      for(int k = 0; k < d; k++){
        sum += (x(i,k) - x(j,k))*(x(i,k) - x(j,k));
      }
      a += q[i] * q[j] / sqrt(sum);
      b += 1 / pow(sum, 4); 
    }
  }
  return (a+b);
}

int getFreeIndex(std::vector<int> idx, int k) {
  const int nPart = idx.size();
  
  for (int i = 0; i < nPart; i++) {
    if (idx[i]==1) k--;
    
    if (k == 0) {
      return i;
    }
  }
  
  return -1;
}

double getDist(std::vector<double> a, std::vector<double> b) {
  const int dim = a.size();
  
  double dist = 0;
  for (int i = 0; i < dim; i++) {
    dist += (a[i] - b[i])*(a[i] - b[i]);
  }
  return std::sqrt(dist);
}

// =======================================================
// ========================================= estimate_clstSize
// =======================================================
double estimate_clstSize(std::vector<std::vector<double>> X) {
  const int nPart = X.size();
  
  const double min_dist = 2;
  
  std::vector<std::vector<int>> clusters;
  std::vector<int>              cluster_sizes;
  
  std::vector<int> idx(nPart, +1);
  int nFree = nPart;
  
  
  while (nFree > 0) 
  {
    // Choose first free particle for new cluster
    int k = -1;
    for (int i = 0; i < nPart; i++) 
    {
      if (idx[i] == 1) 
      {
        k = i;
        idx[i] = 0;
        nFree--;
        break;
      }
    }
    
    // Create new cluster vector
    std::vector<int> temp (nPart, -1);
    clusters.push_back(temp);
    clusters.back()[0] = k;
    cluster_sizes.push_back(1);
    
    
    // Iterate through all cluster particles and look for neighbours.
    for (int j = 0; j < cluster_sizes.back(); j++) 
    {
      const int clst_idx =clusters.back()[j];
      // Add all neighbours of particle j.
      for (int k = 0; k < nFree; k++) 
      {
        int free_idx = getFreeIndex(idx, k+1);
        
        if (getDist(X[clst_idx], X[free_idx]) < min_dist) {
          clusters.back()[cluster_sizes.back()]  = free_idx;
          cluster_sizes.back()  += 1; // Current cluster has grown by 1
          idx[free_idx]          = 0; // Particle has been assigned to a cluster
          nFree                 -= 1; // One further particle is assigned to a cluster
          //k                     -= 1; // Neccessary for correct procedure
        }
        
      }
    }
  }
  
  // Calc mean cluster size and return
  double mean_size = 0;
  for (int i = 0; i < cluster_sizes.size(); i++) {
    mean_size += cluster_sizes[i];
  }
  
  return mean_size/cluster_sizes.size();
}

// =======================================================
// ========================================= MCMC_CPP
// =======================================================
// [[Rcpp::export]]
Rcpp::List MCMC_CPP(int nIt, int nPart, double vol, double t, double sigma, NumericMatrix X0, NumericVector q){
  int d = X0(1,Rcpp::_).size();
  const double l = std::pow(vol, 1./d);
  const double t0= t;
  
  // ----------------------- Observables
  NumericVector dE(nIt, 0.0);
  dE[0] = E_CPP(X0, q);
  
  const int N_clstSize_samples = 10;
  int k_clstSize               = 0;
  const int n_min_clstSize           = nIt-1e4;
  std::vector<double> clstSize(N_clstSize_samples, -1);
  const double stp_clstSize    = (nIt - n_min_clstSize)/N_clstSize_samples;
  // -----------------------
  
  std::vector<std::vector<double>> X(nPart, std::vector<double>(d,0));
  for (int i = 0; i < nPart; i++) {
    for (int j = 0; j < d; j++) {
      X[i][j] = X0(i,j);
    }
  }
  double accept_rate = 0;
  int k  = -1;
  for (int n = 1; n < nIt; n++) {
    k = std::floor(R::runif(0,nPart));
    // ---------------------------------------------------------------------------
    for(int j = 0; j < nPart; j++){
      if(j == k) continue;
      
      double sum = 0;
      for(int dim = 0; dim < d; dim++){
        sum += (X[k][dim] - X[j][dim])*(X[k][dim] - X[j][dim]);
      }
      
      dE[n] -= q[k] * q[j] / sqrt(sum) + 1/ pow(sum, 4);
    }
    // ---------------------------------------------------------------------------
    // Make new candidates (Save old coordinates in case of rejection)
    std::vector<double> old_x(d,0);
    for (int i = 0; i < d; i++) old_x[i] = X[k][i];
    
    std::vector<double> shift_vec(d,0);
    if (d == 1) {
      const double r   = R::rnorm(0, sigma);
      shift_vec = {r};
    } else if (d == 2) {
      const double r   = R::rnorm(0, sigma);
      const double phi = R::runif(0, 1);
      shift_vec = {cos(phi*M_PI)*r, sin(phi*M_PI)*r};
    } else if (d == 3) {
      const double r   = R::rnorm(0, sigma);
      const double phi = R::runif(0, 1);
      const double theta=R::runif(0, 1);
      shift_vec = {cos(phi*M_PI)*sin(theta*M_PI)*r, sin(phi*M_PI)*sin(theta*M_PI)*r, cos(theta*M_PI)*r};
    }
    for(int i=0; i < d; i++){
      X[k][i] += shift_vec[i]; 
      // Periodic boundary wrap
      if      (X[k][i] < -l/2) X[k][i] += l;
      else if (X[k][i] > +l/2) X[k][i] -= l;
    }
    // ---------------------------------------------------------------------------
    for(int j = 0; j < nPart; j++){
      if(j == k) continue;
      
      double sum = 0;
      for(int l = 0; l < d; l++){
        sum += (X[k][l] - X[j][l])*(X[k][l] - X[j][l]);
      }
      
      dE[n] += q[k] * q[j] / sqrt(sum) + 1/ pow(sum, 4);
    }
    // ---------------------------------------------------------------------------
    if (n < 1e4) {
      t = std::exp(std::log(10) * (+2 + n / 1.e4 * (std::log10(t0)-2)));
    } else {
      t = t0;
    }
    if (R::runif(0,1) < std::exp(-1/t * dE[n])) {
      //X = Y;
      accept_rate += 1;
    } else {
      dE[n] = 0;
      for (int i = 0; i < d; i++) X[k][i] = old_x[i];
    }
    // ---------------------------------------------------------------------------
    if ((n-n_min_clstSize) >= k_clstSize * stp_clstSize) {
     clstSize[k_clstSize] = estimate_clstSize(X);
     k_clstSize++;
    }
    // ---------------------------------------------------------------------------
  }
  //Rcout << "Acceptance: " << accept_rate/nIt*100. << "%" << std::endl;
  
  
  for (int i = 0; i < nPart; i++) {
    for (int j = 0; j < d; j++) {
      X0(i,j) = X[i][j];
    }
  }
  
  // Calc mean cluster size
  double mean_size = 0;
  for (int i = 0; i < clstSize.size(); i++) {
    mean_size += clstSize[i];
  }
  mean_size = mean_size/clstSize.size();
  
  Rcpp::List rList = Rcpp::List::create(Named("dE")=dE, Named("X")=X0, Named("Accpetance")=accept_rate/nIt, Named("MeanClusterSize")=mean_size);
  return rList;
}
```

```{r single_simulation}
# --------------------------------------------------------------------------------
# HYPERPARAMETERS:
d               <- 3    # Number of dimensions
particleDensity <- 0.05
vol             <- 2e3  # Volume of space
nIt             <- 2e5  # Number of iterations
beta            <- 1e3
# These below are implied
t     <- 1/beta # Temperature of heat bath
nPart <- ceiling(vol * particleDensity)  # Number of particles
l     <- vol**(1/d)
# --------------------------------------------------------------------------------
# Start configuration:
X0 <- array(data = runif(nPart*d, min=-vol**(1/d)/2, max=vol**(1/d)/2), dim = c(nPart, d))
q <- c(rep(+1,ceiling(nPart/2)),rep(-1,floor(nPart/2)))
# show_particles(X0               , q, vol)
# --------------------------------------------------------------------------------
cat("Run MCMC particles in a potential . .\n")

start_time <- Sys.time()
MCMC_Single_Run <- MCMC_CPP(nIt, nPart, vol, t, sigma=1, X0, q)
end_time <- Sys.time()
# --------------------------------------------------------------------------------
# pdf("particle_config_out.pdf")
show_particles(MCMC_Single_Run$X, q, vol)
# dev.off()
# --------------------------------------------------------------------------------
cat("Number of {positive, negative} particles: {", length(which(q==+1)), ",", length(which(q==-1)),"}\n")
cat("Runtime: ",as.double(t2<- end_time - start_time, units='secs'),"\n")
cat("Acceptrate: ", MCMC_Single_Run$Accpetance,"\n")
cat("Mean Cluster Size: ", MCMC_Single_Run$MeanClusterSize)
# --------------------------------------------------------------------------------
rm(d, particleDensity, vol, beta, t, nPart, l, X0, q, start_time, end_time, t2)
# --------------------------------------------------------------------------------
```

```{r evaluation_acf}
E <- cumsum(MCMC_Single_Run$dE)
plot(x=c(1:nIt),y=E[c(1:nIt)]+abs(min(E[c(1:nIt)]))+1,type='l',log='y', xlim = c(1e2,nIt))

start_time <- Sys.time()
acf(E[c(1e5:nIt)], lag.max = 50000)
cat("ACF runtime: ", as.double(Sys.time() - start_time, units='secs')," seconds \n")
```

```{r evaluation_iat}
# start_time <- Sys.time()
# cat("IAT: ",IAT(E[c(1e5:nIt)]),"\n")
# cat("IAT runtime: ", as.double(Sys.time() - start_time, units='secs')," seconds \n")

start_time <- Sys.time()
cat("IAT_custom: ",IAT_CPP(E[c(1e5:2e5)]),"\n")
cat("IAT runtime: ", as.double(Sys.time() - start_time, units='secs')," seconds \n")

start_time <- Sys.time()
cat("IAT_custom: ",IAT_CPP(E[c(1e5:3e5)]),"\n")
cat("IAT runtime: ", as.double(Sys.time() - start_time, units='secs')," seconds \n")

start_time <- Sys.time()
cat("IAT_custom: ",IAT_CPP(E[c(1e5:4e5)]),"\n")
cat("IAT runtime: ", as.double(Sys.time() - start_time, units='secs')," seconds \n")

start_time <- Sys.time()
cat("IAT_custom: ",IAT_CPP(E[c(2e5:3e5)]),"\n")
cat("IAT runtime: ", as.double(Sys.time() - start_time, units='secs')," seconds \n")

start_time <- Sys.time()
cat("IAT_custom: ",IAT_CPP(E[c(3e5:4e5)]),"\n")
cat("IAT runtime: ", as.double(Sys.time() - start_time, units='secs')," seconds \n")

# rm(start_time)
```



```{r initial_creation_of_frame}
# !!!!!!!!!!!!! BE CAREFUL NOT TO OVERWRITE EXISTING DATA !!!!!!!!!!!!!!!!!
file_name <- "MCMC_Results_V4_w_q.RData"

# Columns:
# 1 "RUN_ID": Run No.
# 2 "IAT"  : Integrated Autocorrelation Time
# 3 "E_end": Energy of Last State
# 4 "dim"  : Number of Dimensions
# 5 "rho"  : Particle Density
# 6 "vol"  : Cuboid Volume
# 7 "beta" : Inverse Temperature
# 8 "nIt"  : Number of MCMC iteration steps
# 9 "nPart": Number of Simulated Particles
#10 "t"    : Temperature
#11 X_end  : 

resFrame <- data.frame(
  "RUN_ID"= 0,
  "IAT"   =NA,
  "E_end" =NA,
  "q"     =NA,
  "dim"   =NA,
  "rho"   =NA,
  "vol"   =NA,
  "beta"  =NA,
  "nIt"   =NA,
  "nPart" =NA,
  "t"     =NA
  )
# save(resFrame, file=file_name)

rm(resFrame)
rm(file_name)
```

```{r save_frame}
# !!!!!!!!!!!!! BE CAREFUL NOT TO OVERWRITE EXISTING DATA !!!!!!!!!!!!!!!!!
# file_name <- "MCMC_Results_V4_w_q.RData"
# save(resFrame, file=file_name)
```

```{r contains}
file_name <- "MCMC_Results_V4_w_q.RData"
load(file_name)
cat("This file contains the following parameter sets:\n")
cat("\t d \t vol \t rho \t beta \t N_beta \t N_samples\n")
v.dims <- resFrame$dim
v.dims <- v.dims[!duplicated(v.dims)]
v.dims <- sort(v.dims[!is.na(v.dims)])

for (c.d in c(1:length(v.dims))) {
  v.vol <- resFrame$vol[which(resFrame$dim==v.dims[c.d])]
  v.vol <- v.vol[!duplicated(v.vol)]
  v.vol <- sort(v.vol[!is.na(v.vol)])

  for (c.v in c(1:length(v.vol))) {
    v.rho <- resFrame$rho[which(resFrame$dim==v.dims[c.d] & resFrame$vol==v.vol[c.v])]
    v.rho <- v.rho[!duplicated(v.rho)]
    v.rho <- sort(v.rho[!is.na(v.rho)])
    
    for (c.r in c(1:length(v.rho))) {
      v.beta <- resFrame$beta[which(resFrame$dim==v.dims[c.d] & resFrame$vol==v.vol[c.v] & resFrame$rho==v.rho[c.r])]
      v.beta <- v.beta[!duplicated(v.beta)]
      v.beta <- sort(v.beta[!is.na(v.beta)])
      
      N_beta <- length(v.beta)
      N_samples <- length(which(resFrame$dim==v.dims[c.d] & resFrame$vol==v.vol[c.v] & resFrame$rho==v.rho[c.r]))
      cat("\t",v.dims[c.d],"\t",v.vol[c.v],"\t",v.rho[c.r],"\t \t", N_beta, "\t", N_samples ,"\n")
    }
  }  
}

rm(v.dims)
```

```{r temperature_variation}
# --------------------------------------------------------------------------------
# LOAD RESULTS DATA FRAME FROM DISK
file_name <- "MCMC_Results_V4_w_q.RData"
load(file_name)
run_no <- max(resFrame$RUN_ID, na.rm=TRUE)+1
# --------------------------------------------------------------------------------
# HYPERPARAMETERS:
d               <- 3    # Number of dimensions
particleDensity <- 0.075
vol             <- 1e4  # Volume of space
nIt             <- 2e5  # Number of iterations
# These below are implied
nPart <- ceiling(vol * particleDensity)  # Number of particles
l     <- vol**(1/d)
# --------------------------------------------------------------------------------
betas <- exp(log(10)*seq(from=-4, to=5, length.out=45))
# betas <- betas[which(c(1:length(betas))%%2==0)]
# betas <- betas[which(c(1:length(betas))%%2==0)]
betas <- betas[which(betas>=1e1)]
# betas <- betas[which(betas< 1e1)]
# --------------- ---------------------------------------
nResamples <- 3
# --------------------------------------------------------------------------------

swatch.mcmc <- rep(0, length(betas))
swatch.iats <- rep(0, length(betas))
swatch.iter <- rep(0, length(betas))

cat("Starting swipe of ",nPart," particles (RUN_ID ",run_no,") over ",length(betas)," points:\n")
for (i in c(1:length(betas))) {
  cat("i:",i,", ",betas[i]," : ")
  
  temp.iats <- rep(NA, nResamples)
  for (j in c(1:nResamples)) {
    cat(j, ", ")
    swatch.iter_start <- Sys.time()
    
    X0 <- array(data = runif(nPart*d, min=-vol**(1/d)/2, max=vol**(1/d)/2), dim = c(nPart, d))
    q  <- sample(c(-1,+1), size=nPart, replace=TRUE)
    
    swatch.mcmc_start <- Sys.time()
    res <- MCMC_CPP(nIt, nPart, vol, 1/betas[i], sigma=1, X0, q) # Make Markov Chain
    swatch.mcmc[i] <- swatch.mcmc[i] + as.double(Sys.time() - swatch.mcmc_start, units='secs')
    
    E <- cumsum(res$dE)
    
    swatch.iats_start <- Sys.time()
    iat <- 1
    # iat <- IAT_CPP(E[c(1e5:nIt)])
    swatch.iats[i] <- swatch.iats[i] + as.double(Sys.time() - swatch.iats_start, units='secs')

    # - - - - - - - - - SAVE RESULT TO FRAME
    resFrame <- rbind(resFrame, list(run_no, iat, E[nIt], res$MeanClusterSize, d, particleDensity, vol, betas[i], nIt, nPart, 1/betas[i]))
    # - - - - - - - - - 
    swatch.iter[i] <- swatch.iter[i] + as.double(Sys.time() - swatch.iter_start, units='secs')
  }
  cat("dur.:",swatch.iter[i]/nResamples,"\n")
}

save(resFrame, file=file_name)
# print(resFrame)
rm(resFrame)

# plot(x=betas, y=swatch.mcmc/nResamples, xlab="BETA", ylab="DURATION per MCMC", type="b", ylim=c(0,1.05*max(c(swatch.mcmc/nResamples,swatch.iter/nResamples))), log="x")
# points(x=betas, y=swatch.iats/nResamples, col="orange", type="b")
# lines(x=betas, y=swatch.iter/nResamples, col="red")
rm(swatch.mcmc, swatch.iter, swatch.iats, swatch.mcmc_start, swatch.iter_start, swatch.iats_start)

rm(q, X0, temp.iats, E, i, j, nResamples, betas, d, particleDensity, vol, nIt, nPart, l, run_no, res, iat) #Cleanup
```

```{r plot_temperature_series_beta}
# --------------------------------------------------------------------------------
# LOAD RESULTS DATA FRAME FROM DISK
file_name <- "MCMC_Results_V4_w_q.RData"
load(file_name)
# print(resFrame)
# --------------------------------------------------------------------------------
# HYPERPARAMETERS:
d               <- 1    # Number of dimensions
particleDensity <- 0.5
vol             <- 2e2  # Volume of space
# beta            <- 1000
# These below are implied
# t     <- 1/beta # Temperature of heat bath
nPart <- ceiling(vol * particleDensity)  # Number of particles
l     <- vol**(1/d)
# --------------------------------------------------------------------------------
x.beta <- resFrame$beta[!duplicated(resFrame$beta)]
x.beta <- sort(x.beta[!is.na(x.beta)])
# x.beta <- x.beta[which(x.beta<0.1)]
y.iat <- array(NA, dim= c(length(x.beta), 2)) # [,1]: IAT, [,2]: Standard Error

for (i in c(1:length(x.beta))) {
  idx <- which(resFrame$dim==d & resFrame$rho==particleDensity & resFrame$vol==vol & resFrame$beta==x.beta[i])
  if (length(idx)!=0) {
    y.iat[i,1] <- mean(resFrame$IAT[idx])
    y.iat[i,2] <- sqrt(var(resFrame$IAT[idx]) / length(resFrame$IAT[idx]))
  }
}

plot(x.beta, y.iat[ ,1], xlim=c(5e-5, 1e5), ylim = c(5e1, 1e5), type = "l", log="xy") 
arrows(x0=x.beta, y0=y.iat[ ,1]-y.iat[ ,2], x1=x.beta, y1=y.iat[ ,1]+y.iat[ ,2], angle=90, code=3, length=0.05)
lines(x=x.beta[which(x.beta>1e1)],y=1.6e4+1e-5*x.beta[which(x.beta>1e1)], col="red")
lines(x=x.beta[which(x.beta<1e1)],y=1e2+1e3*x.beta[which(x.beta<1e1)], col="red")

rm(resFrame)
rm(x.beta, y.iat, i, d, particleDensity, vol, nPart, l, idx, file_name)
```

```{r plot_ticks}
plot(NA, NA, xlim=c(5e-5, 1e5), ylim = c(5e1, 1e5), type = "l", log="xy") 
x.ticks <- exp(log(10)*seq(from=-4, to=5, length.out=46))

x.ticks <- x.ticks[which(c(1:length(x.ticks))%%2==0)]
x.ticks <- x.ticks[which(c(1:length(x.ticks))%%2==1)]

print(x.ticks)
abline(v=x.ticks, col="gray")
```

```{r plot_parallel_rho}
# --------------------------------------------------------------------------------
# LOAD RESULTS DATA FRAME FROM DISK
file_name <- "MCMC_Results_V4_w_q.RData"
load(file_name)
# print(resFrame)
# --------------------------------------------------------------------------------
# HYPERPARAMETERS:
d               <- 1    # Number of dimensions
vol             <- 2e2  # Volume of space
# --------------------------------------------------------------------------------
colors <- c("red", "green", "blue", "orange")

a.rho <- resFrame$rho[which(resFrame$dim==d & resFrame$vol==vol)][!duplicated(resFrame$rho)]
a.rho <- sort(a.rho[!is.na(a.rho)])

plot(NA, NA, xlim=c(1e-7, 1e5), ylim = c(5e1, 1e5), log="xy", xlab="Beta", ylab="IAT") 

for (ridx in c(1:length(a.rho))) {
  x.beta <- resFrame$beta[which(resFrame$rho==a.rho[ridx])]
  x.beta <- x.beta[!duplicated(x.beta)]
  x.beta <- sort(x.beta[!is.na(x.beta)])
  
  y.iat <- array(NA, dim= c(length(x.beta), 2)) # [,1]: IAT, [,2]: Standard Error
  for (i in c(1:length(x.beta))) {
    idx <- which(resFrame$dim==d & resFrame$rho==a.rho[ridx] & resFrame$vol==vol & resFrame$beta==x.beta[i])
    if (length(idx)!=0) {
      y.iat[i,1] <- mean(resFrame$IAT[idx])
      y.iat[i,2] <- sqrt(var(resFrame$IAT[idx]) / length(resFrame$IAT[idx]))
    }
  }
  
  lines(x.beta, y.iat[ ,1], col=colors[ridx]) 
  # arrows(x0=x.beta, y0=y.iat[ ,1]-y.iat[ ,2], x1=x.beta, y1=y.iat[ ,1]+y.iat[ ,2], angle=90, code=3, length=0.05)
}

legend("topleft",legend=c("Rho Values:",a.rho),col=colors[c(0:length(a.rho))], lty=c(0,rep(1,length(a.rho))), cex=1)

rm(resFrame)
rm(x.beta, y.iat, a.rho)
rm(file_name, d, vol)
rm(i, idx, ridx, colors)
```



```{r plot_temperature_series_q}
# --------------------------------------------------------------------------------
file_name <- "MCMC_Results_V4_w_q.RData"
load(file_name)
# --------------------------------------------------------------------------------
d               <- 3   
particleDensity <- 0.075
vol             <- 1e4 
# --------------------------------------------------------------------------------
x.beta <- resFrame$beta[which(resFrame$dim==d & resFrame$vol==vol & resFrame$rho==particleDensity)]
x.beta <- x.beta[!duplicated(x.beta)]
x.beta <- sort(x.beta[!is.na(x.beta)])

# x.beta <- x.beta[which(x.beta>3e0)]

y.q <- array(NA, dim= c(length(x.beta), 2)) # [,1]: IAT, [,2]: Standard Error
y.qsd <- rep(NA, length(x.beta))

for (i in c(1:length(x.beta))) {
  idx <- which(resFrame$dim==d & resFrame$rho==particleDensity & resFrame$vol==vol & resFrame$beta==x.beta[i])
  if (length(idx)!=0) {
    y.q[i,1] <- mean(resFrame$q[idx])
    y.q[i,2] <- sqrt(var(resFrame$q[idx]) / length(idx))
    y.q[i,2] <- getBootstrapMeanError(resFrame$q[idx])
    y.qsd[i] <- sd(resFrame$q[idx])
  }
  
  # if (length(idx)>40) {
  #   hist(resFrame$q[idx], breaks=30)
  # }
}

xlim <- c(5e-5, 1e5)
# xlim <- c(1e-3, max(x.beta,na.rm=TRUE)+1)
ylim <- c(1, max(y.q[ ,1]+y.q[ ,2],na.rm=TRUE))
# ylim <- c(0,10)

y.q[,2][which(y.q[ ,2] < 1e0)] <- NA
err_low <- y.q[ ,1]-y.q[ ,2]
err_high<- y.q[ ,1]+y.q[ ,2]

y.qsd[which(y.qsd < 1e0)] <- NA
sd_low <- y.q[ ,1]-y.qsd
sd_high<- y.q[ ,1]+y.qsd

log <- "x"

plot(x.beta, y.q[ ,1], xlim=xlim, ylim=ylim, type = "l", log=log)
points(x.beta, y.q[ ,1], pch=4, col="black", cex=0.5)
arrows(x0=x.beta, y0=err_low, x1=x.beta, y1=err_high, angle=90, code=3, length=0.02)

rm(resFrame)
rm(x.beta, y.q, i, d, particleDensity, vol, idx, file_name)
rm(err_low, err_high, xlim, ylim, log)
```
```{r plot_parallel_rho_for_q}
# --------------------------------------------------------------------------------
# LOAD RESULTS DATA FRAME FROM DISK
file_name <- "MCMC_Results_V4_w_q.RData"
load(file_name)
# --------------------------------------------------------------------------------
# HYPERPARAMETERS:
d               <- 3    # Number of dimensions
vol             <- 1e4  # Volume of space
# --------------------------------------------------------------------------------
colors <- c("red", "green", "blue", "orange", "purple", "pink", "magenta", "yellow")

a.rho <- resFrame$rho[which(resFrame$dim==d & resFrame$vol==vol)]
a.rho <- a.rho[!duplicated(a.rho)]
a.rho <- sort(a.rho[!is.na(a.rho)])

ylim <- c(1e0, max(resFrame$q[which(resFrame$dim==d & resFrame$vol==vol)]))

plot(NA, NA, xlim=c(5e-5, 1e5), ylim = ylim, log="x", xlab="1/T", ylab="q") 

for (ridx in c(1:length(a.rho))) {
  x.beta <- resFrame$beta[which(resFrame$rho==a.rho[ridx] & resFrame$dim==d & resFrame$vol==vol)]
  x.beta <- x.beta[!duplicated(x.beta)]
  x.beta <- sort(x.beta[!is.na(x.beta)])

  y.q <- array(NA, dim= c(length(x.beta), 2)) # [,1]: IAT, [,2]: Standard Error
  for (i in c(1:length(x.beta))) {
    idx <- which(resFrame$dim==d & resFrame$rho==a.rho[ridx] & resFrame$vol==vol & resFrame$beta==x.beta[i])
    if (length(idx)!=0) {
      y.q[i,1] <- mean(resFrame$q[idx])
      y.q[i,2] <- sqrt(var(resFrame$q[idx]) / length(idx))
    }
  }

  y.q[,2][which(y.q[ ,2] < 1e0)] <- NA
  err_low <- y.q[ ,1]-y.q[ ,2]
  err_high<- y.q[ ,1]+y.q[ ,2]
  
  lines(x.beta, y.q[ ,1], col=colors[ridx]) 
  points(x.beta, y.q[ ,1], pch=4, col="black", cex=0.5)
  arrows(x0=x.beta, y0=y.q[ ,1]-y.q[ ,2], x1=x.beta, y1=y.q[ ,1]+y.q[ ,2], angle=90, code=3, length=0.05)
}

legend("topleft",legend=c("Rho Values:",a.rho),col=c(0,colors[c(1:length(a.rho))]), lty=c(0,rep(1,length(a.rho))), cex=1)

rm(resFrame)
rm(x.beta, y.q, a.rho)
rm(file_name, d, vol)
rm(i, idx, ridx, colors)
```






```{r bootstrap_errors}
getBootstrapMeanError <- function(data){
  N <- length(data)
  N_replicas <- 10*N
  id <- array(sample.int(n=N, size=N_replicas*N, replace = TRUE), dim = c(N_replicas, N))
  
  replicas <- array(data[id], dim = c(N_replicas, N))
  mean_rep <- apply(X = replicas, MARGIN = 1, FUN = mean)
  st_error <- sd(mean_rep)
  return(st_error)
}

chisqr <- function(par, x, y, dy){
  f <- par[1]*x + par[2]
  return(sum((y-f)**2/dy**2))
}

myFit <- function(par, x, y, dy){
  myfit <- optim(par=par, fn=chisqr, y=y, dy=dy, x=x)
  return(list(a=myfit$par[1], b=myfit$par[2], chi2=myfit$value))
}

myFitErrors <- function(x, y, dy){
  N <- length(y)
  N_replicas <- 1500
  replicas <- array(data = NA, dim = c(N_replicas, N))
  for (i in c(1:N)) {
    replicas[ ,i] <- rnorm(n = N_replicas, mean=y[i], sd=dy[i])
  }
  #calculate best fit values (minimise chi2)
  par <- c(1,0)
  best_par <- array(data = NA, dim = c(N_replicas, length(par)+1))
  for (j in c(1:N_replicas)) {
    myfit <- optim(par = par, fn =chisqr, x=x, y=replicas[j, ], dy=dy)
    best_par[j, c(1:length(par))] <- myfit$par
    best_par[j, length(par)+1] <- myfit$value
  }  
  
  #---control results--------------------------------------------------
  # hist(best_par[ ,3], breaks = 100)
  # qqplot(x=qchisq(p = seq(0, 1, 1/N_replicas), df=1, ncp=0.54), y=best_par[ ,3], xlab = "Theoretical Qunatiles", ylab = "Sample Quantiles")
  # hist(best_par[ ,1], breaks = 15, probability = TRUE)
  # qqnorm(best_par[ ,1])
  # hist(best_par[ ,2], breaks = 10, probability = TRUE)
  # qqnorm(best_par[ ,2])
  #--------------------------------------------------------------------
 
   # res_fit <- list(params=c(mean(best_par[ , 1]), mean(best_par[ ,2])), error_params=c(sd(best_par[ , 1]), sd(best_par[ , 2])), chi2 = mean(best_par[ , 3]), error_chi2 = sd(best_par[ ,3]))
  # 
  # return(res_fit)
  return(best_par)
}
```

```{r test_error_calc}
#test------------------------------------------------------------------------------------------------------------
#test error calculation
test <- data.frame(t = c(0,2,4), y= c(0.9417029, 1.9538151, 3.1536958), deltay = c(0.110, 0.095, 0.130))
par <- c(0,1)
res <- myFit(par, test$t, test$y, test$deltay)
res

#test error band plotting
mx <- seq(0,4,0.01)
my <- res$a*mx + res$b
bpars <- myFitErrors(test$t, test$y, test$deltay)

Y <- (apply(bpars[ , c(1:2)], MARGIN = 1, FUN = function(parameter, x){parameter[1]*x + parameter[2]}, x=mx))
dY <- apply(Y, MARGIN = 1, FUN = sd)
plot(x=NA, y=NA, xlim = c(min(test$t), max(test$t)) , ylim = c(0.8,3.5))
polygon(x = c(mx, rev(mx)), y = c(my+dY, rev(my-dY)), col = "green", border = "green")
points(x=test$t,y=test$y)
arrows(x0=test$t, y0=test$y - test$deltay, x1 = test$t, y1=test$y + test$deltay, angle=90, code=3, length=0.05)
lines(x=mx, y=my)
#-----------------------------------------------------------------------------------------------------------------
```

```{r plot_results_with_fit}
# --------------------------------------------------------------------------------
# LOAD RESULTS DATA FRAME FROM DISK
file_name <- "MCMC_Results_V4_w_q.RData"
load(file_name)
# --------------------------------------------------------------------------------
# HYPERPARAMETERS:
d               <- 1    # Number of dimensions
particleDensity <- 0.5
vol             <- 2e2  # Volume of space
nPart <- ceiling(vol * particleDensity)  # Number of particles
l     <- vol**(1/d)
# --------------------------------------------------------------------------------

param <- c(1,1) #slope, y-intercept initial values fit parameter, tbd

# --------------------------------------------------------------------------------
x.beta <- resFrame$beta[which(resFrame$dim==d & resFrame$vol==vol & resFrame$rho==particleDensity)]
x.beta <- x.beta[!duplicated(x.beta)]
x.beta <- sort(x.beta[!is.na(x.beta)])
y.iat <- array(NA, dim= c(length(x.beta), 2)) # [,1]: IAT, [,2]: Standard Error

for (i in c(1:length(x.beta))) {
  idx <- which(resFrame$dim==d & resFrame$rho==particleDensity & resFrame$vol==vol & resFrame$beta==x.beta[i])
  if (length(idx)!=0) {
    y.iat[i,1] <- mean(resFrame$IAT[idx])
    y.iat[i,2] <- getBootstrapMeanError(resFrame$IAT[idx])
  }
}

#----------------------------------------------------------------------------------------------------------------
#plot fit with error band:
fit_range <- c(1e-4, 1e1)
interval_fit <- which(x.beta>=fit_range[1] & x.beta<fit_range[2]) # interval in which a straight line is fitted, tbd
res_fit <- myFit(param, x.beta[interval_fit], y.iat[interval_fit,1], y.iat[interval_fit,2]) #result parameters fit

xvals <- exp(log(10)*seq(from=-4, to=5, length.out=46)) # x values
xvals <- xvals[which(xvals>=fit_range[1] & xvals<fit_range[2])]
fit_line <- res_fit$a*xvals + res_fit$b # fit line

bpars <- myFitErrors(x.beta[interval_fit], y.iat[interval_fit,1], y.iat[interval_fit,2]) # bootstrap replicas for fit parameters

Y <- apply(bpars[ , c(1:2)], MARGIN = 1, FUN = function(parameter, x){parameter[1]*x + parameter[2]}, x=xvals)
dY <- apply(Y, MARGIN = 1, FUN = sd)

plot(x=NA, y=NA, xlim=c(5e-5, 1e5), ylim = c(5e1, 1e5), log="xy", xlab="1/T", ylab="IAT")
polygon(x = c(xvals, rev(xvals)), y = c(fit_line+dY, rev(fit_line-dY)), col = "green", border = "green")
points(x = x.beta, y = y.iat[ ,1])
arrows(x0=x.beta, y0=y.iat[ ,1]-y.iat[ ,2], x1=x.beta, y1=y.iat[ ,1]+y.iat[ ,2], angle=90, code=3, length=0.05)
lines(x=xvals, y=fit_line)
cat("Parameter a: ", res_fit$a, " +- ", sd(bpars[,1]), "\n")
cat("Parameter b: ", res_fit$b, " +- ", sd(bpars[,2]), "\n")
cat("Chisqr of fit: ", res_fit$chi2, "\n")
#----------------------------------------------------------------------------------------------------------------

rm(resFrame)
rm(x.beta, y.iat, i, d, particleDensity, vol, nPart, l, idx, file_name)
```
