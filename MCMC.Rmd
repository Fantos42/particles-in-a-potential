---
title: 'MCMC for particles in a potential'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

source("MCMC_functions.R")
source("DataFrameHelper.R")
```


```{r single_simulation}
# --------------------------------------------------------------------------------
# HYPERPARAMETERS:
d               <- 2    # Number of dimensions
nPart           <- 50
particleDensity <- 0.01
beta            <- 1e7

nIt             <- 0.5e6  # Number of iterations
# nIt             <- 1

t     <- 1/beta # Temperature of heat bath
vol   <- nPart / particleDensity
l     <- vol**(1/d)
# --------------------------------------------------------------------------------
# Start configuration:
X0 <- array(data = runif(nPart*d, min=-vol**(1/d)/2, max=vol**(1/d)/2), dim = c(nPart, d))
q <- c(rep(+1,ceiling(nPart/2)),rep(-1,floor(nPart/2)))

# --------------- Positioned on a regular lattice
X0 <- array(data = NA, dim = c(nPart, d))
nRow  <- ceiling(nPart**(1./d))
nCol  <- round  (nPart**(1./d))

rx <- vol**(1/2) / nRow / 2
rx <- 1.5
ry <- vol**(1/2) / nCol / 2
ry <- 1.5
offset <- vol**(1/2) * (1/2 - 1/2/nCol) - vol**(1/2) / 4

for (i in c(1:nPart)) {
  X0[i,1] <- (floor((i-1) / nCol)) * rx - offset
  X0[i,2] <- ((i-1) %% nCol      ) * ry - offset
}
q <- rep(1, nPart)
for (j in c(2:nPart)) {
  q[j] <- q[j-1]*-1
}
rm(rx,ry,offset)

show_particles(X0, q, vol)
# --------------------------------------------------------------------------------
cat("Run MCMC particles in a potential . .\n")

start_time <- Sys.time()
MCMC_Single_Run <- MCMC_CPP(nIt, nPart, vol, t, sigma=1, X0, q)
end_time <- Sys.time()
# --------------------------------------------------------------------------------
# pdf("particle_config_out.pdf")
show_particles(MCMC_Single_Run$X, q, vol)
# dev.off()
# --------------------------------------------------------------------------------
cat("Number of {positive, negative} particles: {", length(which(q==+1)), ",", length(which(q==-1)),"}\n")
cat("Runtime: ",as.double(t2<- end_time - start_time, units='secs'),"\n")
cat("Acceptrate: ", MCMC_Single_Run$Accpetance*100,"%\n")
cat("q: ", MCMC_Single_Run$q, "\n")
cat("Omega: ", mean(MCMC_Single_Run$omega), "\n")
cat("Lambda: ", mean(MCMC_Single_Run$lambda), "\n")
cat("Kappa: ", mean(MCMC_Single_Run$kappa), "\n")
# print(MCMC_Single_Run$X)
# print(vol**(1/d)/2)
# --------------------------------------------------------------------------------
rm(d, particleDensity, vol, beta, t, nPart, l, X0, q, start_time, end_time, t2)
# --------------------------------------------------------------------------------
```

```{r evaluation_acf}
E <- cumsum(MCMC_Single_Run$dE)
E <- MCMC_Single_Run$dE
# print(MCMC_Single_Run$dE)
x.ticks <- c(1e5:nIt)
plot(x=x.ticks,y=E[x.ticks],type='l',log='')
# plot(x=x.ticks,y=E[x.ticks]+abs(min(E[x.ticks]))+1,type='l',log='y')
rm(x.ticks)

acf_range <- c((nIt-1e5):nIt)
start_time <- Sys.time()
acf(E[acf_range], lag.max = 50000)
cat("ACF runtime: ", as.double(Sys.time() - start_time, units='secs')," seconds \n")

acf_range <- c((nIt-3e5):nIt)
start_time <- Sys.time()
cat("IAT_custom: ",IAT_CPP(E[acf_range]),"\n")
cat("IAT runtime: ", as.double(Sys.time() - start_time, units='secs')," seconds \n")
```

```{r}
myCreateNewFrame("MCMC_Results_V6.RData")

myShowContentOverview("MCMC_Results_V6.RData")
```

```{r MCMC_Swipe}
# --------------------------------------------------------------------------------
# LOAD RESULTS DATA FRAME FROM DISK
file_name <- "MCMC_Results_V6.RData"
load(file_name)
run_no <- max(resFrame$RUN_ID, na.rm=TRUE)+1
# --------------------------------------------------------------------------------
# HYPERPARAMETERS:
dim             <- 2   
nPart           <- 50
rho             <- 0.02

nIt             <- 0.5e6
nResamples      <- 2
# --------------------------------------------------------------------------------
# Betas To Calculate
x.beta <- exp(log(10)*seq(from=-7, to=7, length.out=71))

x.beta <- x.beta[which(c(1:length(x.beta))%%2==0)]
x.beta <- x.beta[which(c(1:length(x.beta))%%2==0)]
x.beta <- x.beta[which(c(1:length(x.beta))%%2==0)]
x.beta <- x.beta[which(c(1:length(x.beta))%%2==0)]
# x.beta <- x.beta[which(c(1:length(x.beta))%%2==0)]
# x.beta <- x.beta[which(x.beta>=1e1)]
# x.beta <- x.beta[which(x.beta< 1e1)]
# --------------------------------------------------------------------------------

resFrame <- myMCMCSwipe(dim=dim, nPart=nPart, rho=rho, nIt=nIt, nResamples=nResamples, x.beta=x.beta, df=resFrame)

save(resFrame, file=file_name)
rm(resFrame)

rm(file_name, run_no, dim, nPart, rho, nIt, nResamples, x.beta)
```


```{r plot_orderParam}
source("DataFrameHelper.R")
file_name <- "MCMC_Results_V6.RData"
load(file_name)
# --------------------------------------------------------------------------------
dim             <- 2   
nPart           <- 50
rho             <- 0.02
vol             <- nPart/rho
# --------------------------------------------------------------------------------
x.beta <- myGetBetaValues(dim=dim, vol=vol, rho=rho)

# x.beta <- x.beta[which(x.beta>3e0)]

plt.data <- myGetObservables(dim=dim, vol=vol, rho=rho, beta=x.beta)
rm(x.beta)

myPlotData(1/plt.data$x, plt.data$y.q     , plt.data$y.q_Err     )
# myPlotData(1/plt.data$x, plt.data$y.lambda, plt.data$y.lambda_Err)
# myPlotData(1/plt.data$x, plt.data$y.omega , plt.data$y.omega_Err )
# myPlotData(1/plt.data$x, plt.data$y.kappa , plt.data$y.kappa_Err )

rm(resFrame)
rm(plt.data, dim, rho, vol, file_name)
```
```{r plot_mult_orderparam}
source("DataFrameHelper.R")
file_name <- "MCMC_Results_V5.RData"
load(file_name)
# --------------------------------------------------------------------------------
dim             <- 2   
nPart           <- 50
# rho             <- 0.02
# vol             <- nPart/rho
# --------------------------------------------------------------------------------
colors <- c("red", "green", "blue", "orange", "purple", "pink", "magenta", "yellow")

a.rho <- resFrame$rho[which(resFrame$dim==dim & resFrame$nPart==nPart)]
a.rho <- a.rho[!duplicated(a.rho)]
a.rho <- sort(a.rho[!is.na(a.rho)])

print(a.rho)

# ylim <- c(1e0, max(resFrame$q[which(resFrame$dim==d & resFrame$vol==vol)]))
# 
# plot(NA, NA, xlim=c(5e-5, 1e5), ylim = ylim, log="x", xlab="1/T", ylab="q") 
# 
# for (ridx in c(1:length(a.rho))) {
#   x.beta <- resFrame$beta[which(resFrame$rho==a.rho[ridx] & resFrame$dim==d & resFrame$vol==vol)]
#   x.beta <- x.beta[!duplicated(x.beta)]
#   x.beta <- sort(x.beta[!is.na(x.beta)])
# 
#   y.q <- array(NA, dim= c(length(x.beta), 2)) # [,1]: IAT, [,2]: Standard Error
#   for (i in c(1:length(x.beta))) {
#     idx <- which(resFrame$dim==d & resFrame$rho==a.rho[ridx] & resFrame$vol==vol & resFrame$beta==x.beta[i])
#     if (length(idx)!=0) {
#       y.q[i,1] <- mean(resFrame$q[idx])
#       y.q[i,2] <- sqrt(var(resFrame$q[idx]) / length(idx))
#     }
#   }
# 
#   y.q[,2][which(y.q[ ,2] < 1e0)] <- NA
#   err_low <- y.q[ ,1]-y.q[ ,2]
#   err_high<- y.q[ ,1]+y.q[ ,2]
#   
#   lines(x.beta, y.q[ ,1], col=colors[ridx]) 
#   points(x.beta, y.q[ ,1], pch=4, col="black", cex=0.5)
#   arrows(x0=x.beta, y0=y.q[ ,1]-y.q[ ,2], x1=x.beta, y1=y.q[ ,1]+y.q[ ,2], angle=90, code=3, length=0.05)
# }
# 
# legend("topleft",legend=c("Rho Values:",a.rho),col=c(0,colors[c(1:length(a.rho))]), lty=c(0,rep(1,length(a.rho))), cex=1)
# 
# rm(resFrame)
# rm(x.beta, y.q, a.rho)
# rm(file_name, d, vol)
# rm(i, idx, ridx, colors)
```







```{r plot_temperature_series_beta}
# --------------------------------------------------------------------------------
# LOAD RESULTS DATA FRAME FROM DISK
file_name <- "MCMC_Results_V4_w_q.RData"
load(file_name)
# print(resFrame)
# --------------------------------------------------------------------------------
# HYPERPARAMETERS:
d               <- 1    # Number of dimensions
particleDensity <- 0.5
vol             <- 2e2  # Volume of space
# beta            <- 1000
# These below are implied
# t     <- 1/beta # Temperature of heat bath
nPart <- ceiling(vol * particleDensity)  # Number of particles
l     <- vol**(1/d)
# --------------------------------------------------------------------------------
x.beta <- resFrame$beta[!duplicated(resFrame$beta)]
x.beta <- sort(x.beta[!is.na(x.beta)])
# x.beta <- x.beta[which(x.beta<0.1)]
y.iat <- array(NA, dim= c(length(x.beta), 2)) # [,1]: IAT, [,2]: Standard Error

for (i in c(1:length(x.beta))) {
  idx <- which(resFrame$dim==d & resFrame$rho==particleDensity & resFrame$vol==vol & resFrame$beta==x.beta[i])
  if (length(idx)!=0) {
    y.iat[i,1] <- mean(resFrame$IAT[idx])
    y.iat[i,2] <- sqrt(var(resFrame$IAT[idx]) / length(resFrame$IAT[idx]))
  }
}

plot(x.beta, y.iat[ ,1], xlim=c(5e-5, 1e5), ylim = c(5e1, 1e5), type = "l", log="xy") 
arrows(x0=x.beta, y0=y.iat[ ,1]-y.iat[ ,2], x1=x.beta, y1=y.iat[ ,1]+y.iat[ ,2], angle=90, code=3, length=0.05)
lines(x=x.beta[which(x.beta>1e1)],y=1.6e4+1e-5*x.beta[which(x.beta>1e1)], col="red")
lines(x=x.beta[which(x.beta<1e1)],y=1e2+1e3*x.beta[which(x.beta<1e1)], col="red")

rm(resFrame)
rm(x.beta, y.iat, i, d, particleDensity, vol, nPart, l, idx, file_name)
```

```{r plot_ticks}
plot(NA, NA, xlim=c(7e-6, 1e6), ylim = c(5e1, 1e5), type = "l", log="xy") 
x.ticks <- exp(log(10)*seq(from=-7, to=7, length.out=71))

x.ticks <- x.ticks[which(c(1:length(x.ticks))%%2==0)]
x.ticks <- x.ticks[which(c(1:length(x.ticks))%%2==0)]

# print(x.ticks)
abline(v=x.ticks, col="gray")
```

```{r plot_parallel_rho}
# --------------------------------------------------------------------------------
# LOAD RESULTS DATA FRAME FROM DISK
file_name <- "MCMC_Results_V4_w_q.RData"
load(file_name)
# print(resFrame)
# --------------------------------------------------------------------------------
# HYPERPARAMETERS:
d               <- 1    # Number of dimensions
vol             <- 2e2  # Volume of space
# --------------------------------------------------------------------------------
colors <- c("red", "green", "blue", "orange")

a.rho <- resFrame$rho[which(resFrame$dim==d & resFrame$vol==vol)][!duplicated(resFrame$rho)]
a.rho <- sort(a.rho[!is.na(a.rho)])

plot(NA, NA, xlim=c(1e-7, 1e5), ylim = c(5e1, 1e5), log="xy", xlab="Beta", ylab="IAT") 

for (ridx in c(1:length(a.rho))) {
  x.beta <- resFrame$beta[which(resFrame$rho==a.rho[ridx])]
  x.beta <- x.beta[!duplicated(x.beta)]
  x.beta <- sort(x.beta[!is.na(x.beta)])
  
  y.iat <- array(NA, dim= c(length(x.beta), 2)) # [,1]: IAT, [,2]: Standard Error
  for (i in c(1:length(x.beta))) {
    idx <- which(resFrame$dim==d & resFrame$rho==a.rho[ridx] & resFrame$vol==vol & resFrame$beta==x.beta[i])
    if (length(idx)!=0) {
      y.iat[i,1] <- mean(resFrame$IAT[idx])
      y.iat[i,2] <- sqrt(var(resFrame$IAT[idx]) / length(resFrame$IAT[idx]))
    }
  }
  
  lines(x.beta, y.iat[ ,1], col=colors[ridx]) 
  # arrows(x0=x.beta, y0=y.iat[ ,1]-y.iat[ ,2], x1=x.beta, y1=y.iat[ ,1]+y.iat[ ,2], angle=90, code=3, length=0.05)
}

legend("topleft",legend=c("Rho Values:",a.rho),col=colors[c(0:length(a.rho))], lty=c(0,rep(1,length(a.rho))), cex=1)

rm(resFrame)
rm(x.beta, y.iat, a.rho)
rm(file_name, d, vol)
rm(i, idx, ridx, colors)
```

```{r plot_temperature_series_q}
# --------------------------------------------------------------------------------
file_name <- "MCMC_Results_V5.RData"
load(file_name)
# --------------------------------------------------------------------------------
d               <- 2   
particleDensity <- 36/4e2
vol             <- 4e2
# --------------------------------------------------------------------------------
betaVals <- myGetBetaValues(dim=d, vol=vol, rho=particleDensity)

# x.beta <- x.beta[which(x.beta>3e0)]

plt.data <- myGetMeanQValues(dim=d, vol=vol, rho=particleDensity, beta=betaVals)
rm(betaVals)


myPlotData(plt.data)

# x.b <- exp(log(10)*seq(from=-4, to=5, length.out=45))
# x.b <- x.b[which(x.b>0.5e0)]
# y.q <- 2 + 4 * x.b
# lines(x.b, y.q)

rm(resFrame)
rm(plt.data, d, particleDensity, vol, file_name)
```

```{r plot_parallel_rho_for_q}
# --------------------------------------------------------------------------------
# LOAD RESULTS DATA FRAME FROM DISK
file_name <- "MCMC_Results_V4_w_q.RData"
load(file_name)
# --------------------------------------------------------------------------------
# HYPERPARAMETERS:
d               <- 3    # Number of dimensions
vol             <- 1e4  # Volume of space
# --------------------------------------------------------------------------------
colors <- c("red", "green", "blue", "orange", "purple", "pink", "magenta", "yellow")

a.rho <- resFrame$rho[which(resFrame$dim==d & resFrame$vol==vol)]
a.rho <- a.rho[!duplicated(a.rho)]
a.rho <- sort(a.rho[!is.na(a.rho)])

ylim <- c(1e0, max(resFrame$q[which(resFrame$dim==d & resFrame$vol==vol)]))

plot(NA, NA, xlim=c(5e-5, 1e5), ylim = ylim, log="x", xlab="1/T", ylab="q") 

for (ridx in c(1:length(a.rho))) {
  x.beta <- resFrame$beta[which(resFrame$rho==a.rho[ridx] & resFrame$dim==d & resFrame$vol==vol)]
  x.beta <- x.beta[!duplicated(x.beta)]
  x.beta <- sort(x.beta[!is.na(x.beta)])

  y.q <- array(NA, dim= c(length(x.beta), 2)) # [,1]: IAT, [,2]: Standard Error
  for (i in c(1:length(x.beta))) {
    idx <- which(resFrame$dim==d & resFrame$rho==a.rho[ridx] & resFrame$vol==vol & resFrame$beta==x.beta[i])
    if (length(idx)!=0) {
      y.q[i,1] <- mean(resFrame$q[idx])
      y.q[i,2] <- sqrt(var(resFrame$q[idx]) / length(idx))
    }
  }

  y.q[,2][which(y.q[ ,2] < 1e0)] <- NA
  err_low <- y.q[ ,1]-y.q[ ,2]
  err_high<- y.q[ ,1]+y.q[ ,2]
  
  lines(x.beta, y.q[ ,1], col=colors[ridx]) 
  points(x.beta, y.q[ ,1], pch=4, col="black", cex=0.5)
  arrows(x0=x.beta, y0=y.q[ ,1]-y.q[ ,2], x1=x.beta, y1=y.q[ ,1]+y.q[ ,2], angle=90, code=3, length=0.05)
}

legend("topleft",legend=c("Rho Values:",a.rho),col=c(0,colors[c(1:length(a.rho))]), lty=c(0,rep(1,length(a.rho))), cex=1)

rm(resFrame)
rm(x.beta, y.q, a.rho)
rm(file_name, d, vol)
rm(i, idx, ridx, colors)
```

```{r plot_results_with_fit}
# --------------------------------------------------------------------------------
# LOAD RESULTS DATA FRAME FROM DISK
file_name <- "MCMC_Results_V4_w_q.RData"
load(file_name)
# --------------------------------------------------------------------------------
# HYPERPARAMETERS:
d               <- 1    # Number of dimensions
particleDensity <- 0.5
vol             <- 2e2  # Volume of space
nPart <- ceiling(vol * particleDensity)  # Number of particles
l     <- vol**(1/d)
# --------------------------------------------------------------------------------

param <- c(1,1) #slope, y-intercept initial values fit parameter, tbd

# --------------------------------------------------------------------------------
x.beta <- resFrame$beta[which(resFrame$dim==d & resFrame$vol==vol & resFrame$rho==particleDensity)]
x.beta <- x.beta[!duplicated(x.beta)]
x.beta <- sort(x.beta[!is.na(x.beta)])
y.iat <- array(NA, dim= c(length(x.beta), 2)) # [,1]: IAT, [,2]: Standard Error

for (i in c(1:length(x.beta))) {
  idx <- which(resFrame$dim==d & resFrame$rho==particleDensity & resFrame$vol==vol & resFrame$beta==x.beta[i])
  if (length(idx)!=0) {
    y.iat[i,1] <- mean(resFrame$IAT[idx])
    y.iat[i,2] <- getBootstrapMeanError(resFrame$IAT[idx])
  }
}

#----------------------------------------------------------------------------------------------------------------
#plot fit with error band:
fit_range <- c(1e-4, 1e1)
interval_fit <- which(x.beta>=fit_range[1] & x.beta<fit_range[2]) # interval in which a straight line is fitted, tbd
res_fit <- myFit(param, x.beta[interval_fit], y.iat[interval_fit,1], y.iat[interval_fit,2]) #result parameters fit

xvals <- exp(log(10)*seq(from=-4, to=5, length.out=46)) # x values
xvals <- xvals[which(xvals>=fit_range[1] & xvals<fit_range[2])]
fit_line <- res_fit$a*xvals + res_fit$b # fit line

bpars <- myFitErrors(x.beta[interval_fit], y.iat[interval_fit,1], y.iat[interval_fit,2]) # bootstrap replicas for fit parameters

Y <- apply(bpars[ , c(1:2)], MARGIN = 1, FUN = function(parameter, x){parameter[1]*x + parameter[2]}, x=xvals)
dY <- apply(Y, MARGIN = 1, FUN = sd)

plot(x=NA, y=NA, xlim=c(5e-5, 1e5), ylim = c(5e1, 1e5), log="xy", xlab="1/T", ylab="IAT")
polygon(x = c(xvals, rev(xvals)), y = c(fit_line+dY, rev(fit_line-dY)), col = "green", border = "green")
points(x = x.beta, y = y.iat[ ,1])
arrows(x0=x.beta, y0=y.iat[ ,1]-y.iat[ ,2], x1=x.beta, y1=y.iat[ ,1]+y.iat[ ,2], angle=90, code=3, length=0.05)
lines(x=xvals, y=fit_line)
cat("Parameter a: ", res_fit$a, " +- ", sd(bpars[,1]), "\n")
cat("Parameter b: ", res_fit$b, " +- ", sd(bpars[,2]), "\n")
cat("Chisqr of fit: ", res_fit$chi2, "\n")
#----------------------------------------------------------------------------------------------------------------

rm(resFrame)
rm(x.beta, y.iat, i, d, particleDensity, vol, nPart, l, idx, file_name)
```


```{r results_other_observables}
nPart <- length(MCMC_Single_Run$X[,1])
cat("nPart = ",nPart)

mean_particle_dist <- mean(MCMC_Single_Run$ParticleDists)
error_mean_particle_dist <- getBootstrapMeanError(MCMC_Single_Run$ParticleDists, replicaFactor = 3)

mean_nearest_neigh_dist <- mean(MCMC_Single_Run$NearestNeighDists)
error_mean_nearest_neigh_dist <- getBootstrapMeanError(MCMC_Single_Run$NearestNeighDists, replicaFactor = 3)

mean_number_particles_direct_neigh <- mean(MCMC_Single_Run$NParticlesNeighbourhood)
error_mean_number_particles_direct_neigh <- getBootstrapMeanError(MCMC_Single_Run$NParticlesNeighbourhood, replicaFactor = 3)
```

```{r}
cat("Average Distance between all particles: ", mean_particle_dist, "+-" , error_mean_particle_dist, "\n")
cat("Average Distance to nearest Neighbour: ", mean_nearest_neigh_dist, "+-" , error_mean_nearest_neigh_dist, "\n")
cat("Average Number of Particles in direct Neighbourhood: ", mean_number_particles_direct_neigh, "+-" , error_mean_number_particles_direct_neigh, "\n")
   
hist(MCMC_Single_Run$ParticleDists)
hist(MCMC_Single_Run$NearestNeighDists, breaks=50, freq = FALSE)
hist(MCMC_Single_Run$NParticlesNeighbourhood, breaks=20)
```