---
title: 'MCMC for particles in a potential'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

source("MCMC_functions.R")
source("DataFrameHelper.R")
```


```{r single_simulation}
# --------------------------------------------------------------------------------
# HYPERPARAMETERS:
dim             <- 3    # Number of dimensions
nPart           <- 40
rho             <- 0.1
t               <- 1e-3  # Temperature of heat bath


nIt             <- 1e6  # Number of iterations
# nIt             <- 1
beta            <- 1/t

vol   <- nPart / rho
l     <- vol**(1/dim)
# --------------------------------------------------------------------------------
# Start configuration: (type="ordered" or type="random")
type <- "random"
init_config <- gen_initConfig(type=type, dim=dim, vol=vol, nPart=nPart)
X0 <- init_config$X0
q  <- init_config$q
rm(init_config)
show_particles(X0, q, vol)
# --------------------------------------------------------------------------------
cat("Run MCMC particles in a potential . .\n")

start_time <- Sys.time()
MCMC_Single_Run <- MCMC_CPP(nIt, nPart, vol, t, sigma=1, N_burnIn=0, X0, q)
end_time <- Sys.time()
# --------------------------------------------------------------------------------
# pdf("config_rho010_t0001.pdf")
show_particles(MCMC_Single_Run$X, q, vol)
# dev.off()
# --------------------------------------------------------------------------------
cat("Number of {positive, negative} particles: {", length(which(q==+1)), ",", length(which(q==-1)),"}\n")
cat("Runtime: ",as.double(t2<- end_time - start_time, units='secs'),"\n")
cat("Acceptrate: ", MCMC_Single_Run$Accpetance*100,"%\n")
cat("q: ", mean(MCMC_Single_Run$q), "\n")
cat("Omega: ", mean(MCMC_Single_Run$omega), "\n")
cat("Lambda: ", mean(MCMC_Single_Run$lambda), "\n")
cat("Kappa: ", mean(MCMC_Single_Run$kappa), "\n")
# print(MCMC_Single_Run$X)
# print(vol**(1/dim)/2)
# --------------------------------------------------------------------------------
rm(dim, rho, vol, beta, t, nPart, l, X0, q, start_time, end_time, t2, type, nIt)
# --------------------------------------------------------------------------------
```

```{r evaluation_acf}
nIt             <- 0.5e6
E <- cumsum(MCMC_Single_Run$E)
print(E)
# # E <- MCMC_Single_Run$dE
# # print(MCMC_Single_Run$dE)
# x.ticks <- c(1e1:nIt)
# # plot(x=x.ticks,y=E[x.ticks],type='l',log='')
# # plot(x=x.ticks,y=E[x.ticks]+abs(min(E[x.ticks]))+1,type='l',log='y')
# rm(x.ticks)
# 
# acf_range <- c((nIt-1e5):nIt)
# start_time <- Sys.time()
# # acf(E[acf_range], lag.max = 50000)
# cat("ACF runtime: ", as.double(Sys.time() - start_time, units='secs')," seconds \n")
# 
# acf_range <- c((nIt-3e5):nIt)
# start_time <- Sys.time()
# cat("IAT_custom: ",IAT_CPP(E[acf_range]),"\n")
# cat("IAT runtime: ", as.double(Sys.time() - start_time, units='secs')," seconds \n")
rm(nIt)
```

```{r}
# myCreateNewFrame("MCMC_Results_V8.RData")

myShowContentOverview("MCMC_Results_V8.RData")
```

```{r MCMC_Swipe}
# --------------------------------------------------------------------------------
# LOAD RESULTS DATA FRAME FROM DISK
file_name <- "MCMC_Results_V8.RData"
load(file_name)
run_no <- max(resFrame$RUN_ID, na.rm=TRUE)+1
# --------------------------------------------------------------------------------
# HYPERPARAMETERS:
dim             <- 2
nPart           <- 50
rho             <- 0.05

nIt             <- 0.5e6
nResamples      <- 2

sct             <- "ordered"
# --------------------------------------------------------------------------------
# Betas To Calculate
x.beta <- exp(log(10)*seq(from=-7, to=7, length.out=71))
lowerBound <- 1e-3
upperBound <- 1e+4


# x.beta <- x.beta[which(c(1:length(x.beta))%%2==0)]
# x.beta <- x.beta[which(c(1:length(x.beta))%%2==0)]
# x.beta <- x.beta[which(c(1:length(x.beta))%%2==0)]
# x.beta <- x.beta[which(c(1:length(x.beta))%%2==0)]
# x.beta <- x.beta[which(c(1:length(x.beta))%%2==0)]
# x.beta <- x.beta[which(x.beta>=lowerBound)]
# x.beta <- x.beta[which(x.beta< upperBound)]
# --------------------------------------------------------------------------------

resFrame <- myMCMCSwipe(dim=dim, nPart=nPart, rho=rho, sigma=1, sct=sct, nIt=nIt, nResamples=nResamples, x.beta=x.beta, df=resFrame)

save(resFrame, file=file_name)
rm(resFrame)

rm(file_name, run_no, dim, nPart, rho, nIt, nResamples, x.beta, lowerBound, upperBound)
```


```{r plot_orderParam}
source("DataFrameHelper.R")
file_name <- "MCMC_Results_V8.RData"
load(file_name)
# --------------------------------------------------------------------------------
dim             <- 2   
nPart           <- 50
rho             <- 0.05
vol             <- nPart/rho
# --------------------------------------------------------------------------------
x.beta <- myGetBetaValues(dim=dim, vol=vol, rho=rho)

# x.beta <- x.beta[which(x.beta>3e0)]

plt.data <- myGetObservables(dim=dim, vol=vol, rho=rho, beta=x.beta)
rm(x.beta)

myPlotData(1/plt.data$x, plt.data$y.q     , plt.data$y.q_Err     )
myPlotData(1/plt.data$x, plt.data$y.lambda, plt.data$y.lambda_Err)
myPlotData(1/plt.data$x, plt.data$y.omega , plt.data$y.omega_Err )
myPlotData(1/plt.data$x, plt.data$y.kappa , plt.data$y.kappa_Err )

rm(resFrame)
rm(plt.data, dim, rho, vol, file_name)
```

```{r plots}
source("DataFrameHelper.R")
file_name <- "MCMC_Results_V8.RData"
load(file_name)
# --------------------------------------------------------------------------------
dim             <- 2
nPart           <- 50
rho             <- 0.05
vol             <- nPart/rho
# --------------------------------------------------------------------------------
x.beta <- myGetBetaValues(dim=dim, vol=vol, rho=rho)

plt.data <- myGetObservables(dim=dim, vol=vol, rho=rho, beta=x.beta)
rm(x.beta)

#plot custom
x <- 1/plt.data$x     
y1    <- plt.data$y.q         * 0.1
y1err <- plt.data$y.q_Err     * 0.1
y2    <- plt.data$y.lambda/sqrt(vol)
y2err <- plt.data$y.lambda_Err/sqrt(vol)
y3    <- plt.data$y.omega     * 1.0
y3err <- plt.data$y.omega_Err * 1.0
y4    <- plt.data$y.kappa     * 1.0
y4err <- plt.data$y.kappa_Err * 1.0


xlim <- c(1e-5, 1e5)
ylim <- c(0, max(y1+y1err, y2+y2err, y3+y3err, y4+y4err, na.rm=TRUE))

log <- "x"

plot(NA, NA, xlim=xlim, ylim=ylim, type = "l", log=log, main = "", xlab = "T", ylab = "Value")
points(x, y1, pch=4, col="black", cex=0.5)
points(x, y2, pch=4, col="green", cex=0.5)
points(x, y3, pch=4, col="blue", cex=0.5)
points(x, y4, pch=4, col="red", cex=0.5)
lines(x, y1, col="black")
lines(x, y2, col="green")
lines(x, y3, col="blue")
lines(x, y4, col="red")
arrows(x0=x, y0=y1-y1err, x1=x, y1=y1+y1err, angle=90, code=3, length=0.02, col="black")
arrows(x0=x, y0=y2-y2err, x1=x, y1=y2+y2err, angle=90, code=3, length=0.02, col="green")
arrows(x0=x, y0=y3-y3err, x1=x, y1=y3+y3err, angle=90, code=3, length=0.02, col="blue")
arrows(x0=x, y0=y4-y4err, x1=x, y1=y4+y4err, angle=90, code=3, length=0.02, col="red")

# abline(v=1e-2)

legend("topright", legend = c("q", "omega", "kappa"), lty = c(1,1,1), col = c("black", "blue", "red"))

rm(resFrame)
rm(x, xlim, ylim, y1, y1err, y2, y2err, y3, y3err, y4, y4err, log)
rm(plt.data, dim, rho, vol, nPart, file_name)
```

```{r plot_orderParam}
source("DataFrameHelper.R")
file_name <- "MCMC_Results_V8.RData"
load(file_name)
# --------------------------------------------------------------------------------
dim             <- 2   
nPart           <- 50
# --------------------------------------------------------------------------------
colours <- c("red","green", "blue", "orange", "pink", "magenta")
observables <- c("lambda", "omega", "q", "kappa")
obs_id <- c(8,10,4,12)
y_high <- c(40,2.2,15,3)

z.rho  <- myGetRhoValues(dim=dim, nPart=nPart)
xlim <- c(1e-4, 1e3)


for (j in c(1:length(obs_id))) {
  ylim <- c(0, y_high[j])
  plot(NA, NA, xlim=xlim, ylim=ylim, type = "l", log="x", main = "", xlab = "T", ylab = observables[j])
  
  for (i in c(1:length(z.rho))) {
    x.beta   <- myGetBetaValues (dim=dim, vol=nPart/z.rho[i], rho=z.rho[i])
    plt.data <- myGetObservables(dim=dim, vol=nPart/z.rho[i], rho=z.rho[i], beta=x.beta)
    
    myPointsLinesErrorsData(1./plt.data$x, plt.data[[obs_id[j]]], plt.data[[obs_id[j]+1]], col=colours[i])
    
  }
  legend("topright", legend=z.rho, col=colours, lty=1)  
}

# rm(resFrame)
rm(dim, z.rho, file_name)
```

## deprecated

```{r plot_results_with_fit}
# --------------------------------------------------------------------------------
# LOAD RESULTS DATA FRAME FROM DISK
file_name <- "MCMC_Results_V4_w_q.RData"
load(file_name)
# --------------------------------------------------------------------------------
# HYPERPARAMETERS:
d               <- 1    # Number of dimensions
particleDensity <- 0.5
vol             <- 2e2  # Volume of space
nPart <- ceiling(vol * particleDensity)  # Number of particles
l     <- vol**(1/d)
# --------------------------------------------------------------------------------

param <- c(1,1) #slope, y-intercept initial values fit parameter, tbd

# --------------------------------------------------------------------------------
x.beta <- resFrame$beta[which(resFrame$dim==d & resFrame$vol==vol & resFrame$rho==particleDensity)]
x.beta <- x.beta[!duplicated(x.beta)]
x.beta <- sort(x.beta[!is.na(x.beta)])
y.iat <- array(NA, dim= c(length(x.beta), 2)) # [,1]: IAT, [,2]: Standard Error

for (i in c(1:length(x.beta))) {
  idx <- which(resFrame$dim==d & resFrame$rho==particleDensity & resFrame$vol==vol & resFrame$beta==x.beta[i])
  if (length(idx)!=0) {
    y.iat[i,1] <- mean(resFrame$IAT[idx])
    y.iat[i,2] <- getBootstrapMeanError(resFrame$IAT[idx])
  }
}

#----------------------------------------------------------------------------------------------------------------
#plot fit with error band:
fit_range <- c(1e-4, 1e1)
interval_fit <- which(x.beta>=fit_range[1] & x.beta<fit_range[2]) # interval in which a straight line is fitted, tbd
res_fit <- myFit(param, x.beta[interval_fit], y.iat[interval_fit,1], y.iat[interval_fit,2]) #result parameters fit

xvals <- exp(log(10)*seq(from=-4, to=5, length.out=46)) # x values
xvals <- xvals[which(xvals>=fit_range[1] & xvals<fit_range[2])]
fit_line <- res_fit$a*xvals + res_fit$b # fit line

bpars <- myFitErrors(x.beta[interval_fit], y.iat[interval_fit,1], y.iat[interval_fit,2]) # bootstrap replicas for fit parameters

Y <- apply(bpars[ , c(1:2)], MARGIN = 1, FUN = function(parameter, x){parameter[1]*x + parameter[2]}, x=xvals)
dY <- apply(Y, MARGIN = 1, FUN = sd)

plot(x=NA, y=NA, xlim=c(5e-5, 1e5), ylim = c(5e1, 1e5), log="xy", xlab="1/T", ylab="IAT")
polygon(x = c(xvals, rev(xvals)), y = c(fit_line+dY, rev(fit_line-dY)), col = "green", border = "green")
points(x = x.beta, y = y.iat[ ,1])
arrows(x0=x.beta, y0=y.iat[ ,1]-y.iat[ ,2], x1=x.beta, y1=y.iat[ ,1]+y.iat[ ,2], angle=90, code=3, length=0.05)
lines(x=xvals, y=fit_line)
cat("Parameter a: ", res_fit$a, " +- ", sd(bpars[,1]), "\n")
cat("Parameter b: ", res_fit$b, " +- ", sd(bpars[,2]), "\n")
cat("Chisqr of fit: ", res_fit$chi2, "\n")
#----------------------------------------------------------------------------------------------------------------

rm(resFrame)
rm(x.beta, y.iat, i, d, particleDensity, vol, nPart, l, idx, file_name)
```


```{r results_other_observables}
nPart <- length(MCMC_Single_Run$X[,1])
cat("nPart = ",nPart)

mean_particle_dist <- mean(MCMC_Single_Run$ParticleDists)
error_mean_particle_dist <- getBootstrapMeanError(MCMC_Single_Run$ParticleDists, replicaFactor = 3)

mean_nearest_neigh_dist <- mean(MCMC_Single_Run$NearestNeighDists)
error_mean_nearest_neigh_dist <- getBootstrapMeanError(MCMC_Single_Run$NearestNeighDists, replicaFactor = 3)

mean_number_particles_direct_neigh <- mean(MCMC_Single_Run$NParticlesNeighbourhood)
error_mean_number_particles_direct_neigh <- getBootstrapMeanError(MCMC_Single_Run$NParticlesNeighbourhood, replicaFactor = 3)
```

```{r}
cat("Average Distance between all particles: ", mean_particle_dist, "+-" , error_mean_particle_dist, "\n")
cat("Average Distance to nearest Neighbour: ", mean_nearest_neigh_dist, "+-" , error_mean_nearest_neigh_dist, "\n")
cat("Average Number of Particles in direct Neighbourhood: ", mean_number_particles_direct_neigh, "+-" , error_mean_number_particles_direct_neigh, "\n")
   
hist(MCMC_Single_Run$ParticleDists)
hist(MCMC_Single_Run$NearestNeighDists, breaks=50, freq = FALSE)
hist(MCMC_Single_Run$NParticlesNeighbourhood, breaks=20)
```




```{r plot_autocorrelation}
# --------------------------------------------------------------------------------
# HYPERPARAMETERS:
dim   <- 2    # Number of dimensions
nPart <- 50
rho   <- 0.1

vol   <- nPart / rho
nIt   <- 1e6  # Number of iterations

type <- "random"

t     <- 1e+1
init_config <- gen_initConfig(type=type, dim=dim, vol=vol, nPart=nPart)
MCMC_BurnIn_Run1 <- MCMC_CPP(nIt, nPart, vol, t, sigma=1, N_burnIn=0, init_config$X0, init_config$q)

t     <- 5e-2 
init_config <- gen_initConfig(type=type, dim=dim, vol=vol, nPart=nPart)
MCMC_BurnIn_Run2 <- MCMC_CPP(nIt, nPart, vol, t, sigma=1, N_burnIn=0, init_config$X0, init_config$q)

t     <- 1e-3 
init_config <- gen_initConfig(type=type, dim=dim, vol=vol, nPart=nPart)
MCMC_BurnIn_Run3 <- MCMC_CPP(nIt, nPart, vol, t, sigma=1, N_burnIn=0, init_config$X0, init_config$q)


# show_particles(MCMC_BurnIn_Run$X, init_config$q, vol)
rm(dim, rho, vol, t, nPart, init_config, type)
# --------------------------------------------------------------------------------
```

```{r}
nIt <- 8.5e5
x.ticks <- c(1e0:nIt)[which(c(1e4:nIt)%%500==0)]

# E1 <- MCMC_BurnIn_Run1$E
E2 <- MCMC_BurnIn_Run2$E
E3 <- MCMC_BurnIn_Run3$E

plot(NA, NA, xlim=c(1,nIt), ylim=c(0.001,5), xlab="Markov Chain Step", ylab="Energy", log="y")
# lines(x.ticks, E1[x.ticks], col="red")
lines(x.ticks, E2[x.ticks] - min(E2[x.ticks]), col="orange")
lines(x.ticks, E3[x.ticks] - min(E3[x.ticks]), col="blue")

plot(NA, NA, xlim=c(1,nIt), ylim=c(-1,2), xlab="Markov Chain Step", ylab="Energy", log="")
lines(x.ticks, E2[x.ticks] - mean(E2[c((nIt-1e5):nIt)]), col="orange")
lines(x.ticks, E3[x.ticks] - mean(E3[c((nIt-1e5):nIt)]), col="blue")
abline(h=0)
# abline(v=nIt)

rm(x.ticks)
```

```{r}
nInt             <- 2e5
lag.max          <- 10000
acf_range <- c((nIt-nInt):nIt)

E1 <- MCMC_BurnIn_Run1$E
acf1 <- acf(E1[acf_range], lag.max = lag.max, plot=TRUE)

E2 <- MCMC_BurnIn_Run2$E
acf2 <- acf(E2[acf_range], lag.max = lag.max, plot=TRUE)

E3 <- MCMC_BurnIn_Run3$E
acf3 <- acf(E3[acf_range], lag.max = lag.max, plot=TRUE)

rm(nInt, acf_range)
```

```{r}
x <- c(1:lag.max)[which((c(1:lag.max)-1) %% 100 == 0)]
y1<- acf1$acf     [which((c(1:lag.max)-1) %% 100 == 0)]
y2<- acf2$acf     [which((c(1:lag.max)-1) %% 100 == 0)]
y3<- acf3$acf     [which((c(1:lag.max)-1) %% 100 == 0)]

plot(NA, xlim=c(0,lag.max), ylim=c(-0.45 ,1), xlab="Lag", ylab="ACF")
lines(x, y1, col="red")
lines(x, y2, col="green")
lines(x, y3, col="blue")
abline(h=0)


plot(NA, xlim=c(1,nIt), ylim=c(-30,10), xlab="Markov Chain Step", ylab="Energy")
lines(x, E1, col="red")
lines(x, E2, col="green")
lines(x, E3, col="blue")
abline(h=0)

rm(x,y1,y2,y3)
```















